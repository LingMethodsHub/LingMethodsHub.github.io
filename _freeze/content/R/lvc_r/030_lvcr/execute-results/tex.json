{
  "hash": "e4bfaa936dbcd9360bdd494aaabc8a47",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting to Know Your Data\"\ndate: \"2022-9-27\"\nlicense: \"CC-BY-SA 4.0\"\ndescription: \"Getting a snapshot of your data. Types of data and data structures. Getting the dimensions of your data. Introducting the (t/d) dataset. \"\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Getting to know the (t, d) deletion data\n\nIf you followed the previous section you now have an object in *R* called `td`. If not, you can load it now with either of the following codes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntd <-read.delim(\"https://www.dropbox.com/s/jxlfuogea3lx2pu/deletiondata.txt?dl=1\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntd <- read.delim(\"Data/deletiondata.txt\")\n```\n:::\n\n\n### Getting a Snapshot of the Data\n\nNow that you have some data loaded into *R* you can start exploring it. At any time you can type `td` into the console window to see what that object actually represents. Try it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntd\n```\n:::\n\n\nTo find out how many columns there are in your data frame (this is what *R* calls spreadsheets), use the function `nrow()`. Similarly, to find out how many columns are in the data frame, use the function `ncol()`. The function `dim()` gives both.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6989\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6989   12\n```\n\n\n:::\n:::\n\n\nThere are 6,989 rows and 12 columns in this data frame.\n\nThe `summary()` function is one of the most useful functions you'll use in *R*. It gives you a quick snapshot of a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Dep.Var             Stress            Category          Morph.Type       \n Length:6989        Length:6989        Length:6989        Length:6989       \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n    Before             After             Speaker               YOB      \n Length:6989        Length:6989        Length:6989        Min.   :1915  \n Class :character   Class :character   Class :character   1st Qu.:1952  \n Mode  :character   Mode  :character   Mode  :character   Median :1965  \n                                                          Mean   :1967  \n                                                          3rd Qu.:1991  \n                                                          Max.   :1999  \n     Sex             Education             Job            Phoneme.Dep.Var   \n Length:6989        Length:6989        Length:6989        Length:6989       \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n```\n\n\n:::\n:::\n\n\nThe `summary()` function shows you the name of all the columns in the data frame and what each column contains.\n\nWhen you import a data frame into *R*, *R* automatically decides what type of data each column contains. Any data frame columns where all cells contain only numbers are assumed to `numeric` or `integer` data (depending on if there are decimal values). Any columns that include letters will be assumed to be `character` data.\n\nFor `numeric` or `integer` data (like `YOB`, or year of birth of the speakers in the `td` data), the `summary()` function will tell you the mean, the median, the minimum value, the maximum value, and the values of the first and third quartiles. The mean is the arithmetic mean, which is the sum of all the values in a column divided by the number of values in a column. Fifty percent of the values in the column are equal to or less than the mean and 50% of the values in the column are greater than or less than the mean. The mean can also be thought of as the 2nd quartile. The median is exact middle point of the values in the column ordered from smallest to largest. For *normally distributed* data, the mean and the median should be close to the same value. Not all data, however, is normally distributed, which is sometimes a problem, and sometimes not a problem. If a certain test expects numerical data to be normally distributed these instructions will explain what to do, but for now, it's just good to know what mean and median indicate. Twenty-five percent of the values in the column are equal to or less than the 1st quartile and 75% of the values in the column are equal to or less than the 3rd quartile. The minimum value is the lowest value in a column; the maximum value is the highest number in a column. These values can be used to construct a **box and whisker** plot:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Box and whisker plot of `YOB` (Year of Birth) in the `td` data frame](030_lvcr_files/figure-pdf/fig-yob-1.pdf){#fig-yob}\n:::\n:::\n\n\n\n\n\nThe bottom **whisker** ends at the minimum value of 1910. The bottom line of the **box** displays the first quartile value of 1952. The thick bar in the middle of the **box** is at the second quartile value/mean of 1965. The top line of the *box* ends at the third quartile value of 1991. The range from the first quartile to the third quartile is called the **interquartile range**. The top **whisker** ends at the maximum value of 1999. Sometimes extremely high or extremely low values are more than $1.5\\times$ the interquartile range from the top or bottom of the box. In these cases the whiskers will extend out to the last value within $1.5\\times$ the interquartile range and anything beyond that will be an **outlier** and identified with a small circle, as in @fig-tokens.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Box and whisker plot of the number of tokens per speaker in the `td` data frame](030_lvcr_files/figure-pdf/fig-tokens-1.pdf){#fig-tokens}\n:::\n:::\n\n\nThe function `names()` returns a vector (a series of items in a line, separated by commas) of the column names. This function can be useful as a quick way to get the names of each column. You will need to use these names quite often when writing other commands. `colnames()` returns the same information; `ls()` returns the same information, but ordered alphabetically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Dep.Var\"         \"Stress\"          \"Category\"        \"Morph.Type\"     \n [5] \"Before\"          \"After\"           \"Speaker\"         \"YOB\"            \n [9] \"Sex\"             \"Education\"       \"Job\"             \"Phoneme.Dep.Var\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Dep.Var\"         \"Stress\"          \"Category\"        \"Morph.Type\"     \n [5] \"Before\"          \"After\"           \"Speaker\"         \"YOB\"            \n [9] \"Sex\"             \"Education\"       \"Job\"             \"Phoneme.Dep.Var\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"After\"           \"Before\"          \"Category\"        \"Dep.Var\"        \n [5] \"Education\"       \"Job\"             \"Morph.Type\"      \"Phoneme.Dep.Var\"\n [9] \"Sex\"             \"Speaker\"         \"Stress\"          \"YOB\"            \n```\n\n\n:::\n:::\n\n\nThe function `str()` describes the structure of a data frame. It reports similar information as `summary()` but does not include descriptions of each column; however, the layout of the information is sometimes a little easier to read, especially if your data frame has many columns. Here we can see that `YOB` is categorized as `int` (integer) data and all the other columns are `chr` (character) data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t6989 obs. of  12 variables:\n $ Dep.Var        : chr  \"Realized\" \"Realized\" \"Realized\" \"Deletion\" ...\n $ Stress         : chr  \"Stressed\" \"Stressed\" \"Stressed\" \"Stressed\" ...\n $ Category       : chr  \"Function\" \"Function\" \"Function\" \"Function\" ...\n $ Morph.Type     : chr  \"Mono\" \"Mono\" \"Mono\" \"Mono\" ...\n $ Before         : chr  \"Vowel\" \"Vowel\" \"Vowel\" \"Vowel\" ...\n $ After          : chr  \"Pause\" \"Pause\" \"Pause\" \"Pause\" ...\n $ Speaker        : chr  \"BOUF65\" \"CHIF55\" \"CLAF52\" \"CLAM73\" ...\n $ YOB            : int  1965 1955 1952 1973 1915 1941 1953 1953 1958 1946 ...\n $ Sex            : chr  \"F\" \"F\" \"F\" \"M\" ...\n $ Education      : chr  \"Educated\" \"Educated\" \"Educated\" \"Not Educated\" ...\n $ Job            : chr  \"White\" \"White\" \"Service\" \"Blue\" ...\n $ Phoneme.Dep.Var: chr  \"t--Affricate\" \"t--Fricative\" \"t--Affricate\" \"t--Deletion\" ...\n```\n\n\n:::\n:::\n\n\n`head()` will return the first six lines of the data frame. `tail()` provides the last six. For either you can change the number of lines reported using the option `n=`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Dep.Var   Stress Category Morph.Type Before After Speaker  YOB Sex\n1 Realized Stressed Function       Mono  Vowel Pause  BOUF65 1965   F\n2 Realized Stressed Function       Mono  Vowel Pause  CHIF55 1955   F\n3 Realized Stressed Function       Mono  Vowel Pause  CLAF52 1952   F\n4 Deletion Stressed Function       Mono  Vowel Pause  CLAM73 1973   M\n5 Realized Stressed Function       Mono  Vowel Pause  DONF15 1915   F\n6 Realized Stressed Function       Mono  Vowel Pause  DONM41 1941   M\n     Education     Job Phoneme.Dep.Var\n1     Educated   White    t--Affricate\n2     Educated   White    t--Fricative\n3     Educated Service    t--Affricate\n4 Not Educated    Blue     t--Deletion\n5 Not Educated Service    t--Fricative\n6 Not Educated    Blue    t--Fricative\n```\n\n\n:::\n:::\n\n\nThe numbers on the left side of the output are the row number in the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(td, n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Dep.Var   Stress Category Morph.Type Before After Speaker  YOB Sex\n6980 Realized Stressed Function       Mono  Vowel Vowel  STEM42 1942   M\n6981 Realized Stressed Function       Mono  Vowel Vowel  VIKF91 1991   F\n6982 Realized Stressed Function       Mono  Vowel Vowel  VIKF91 1991   F\n6983 Realized Stressed  Lexical       Mono  Nasal Pause  PACM94 1994   M\n6984 Deletion Stressed  Lexical       Mono      S Pause  INGM84 1984   M\n6985 Realized Stressed  Lexical       Mono      S Vowel  INGM84 1984   M\n6986 Realized Stressed Function       Mono  Vowel Pause  GARF16 1916   F\n6987 Realized Stressed  Lexical       Mono  Vowel Pause  GARF87 1987   F\n6988 Deletion Stressed  Lexical       Mono  Vowel Pause  GARF87 1987   F\n6989 Realized Stressed  Lexical       Mono  Vowel Pause  GARF87 1987   F\n        Education     Job Phoneme.Dep.Var\n6980 Not Educated Service d--Glottal Stop\n6981      Student Student         d--Flap\n6982      Student Student         d--Flap\n6983      Student Student            d--T\n6984     Educated Service     t--Deletion\n6985     Educated Service t--Glottal Stop\n6986 Not Educated Service    t--Fricative\n6987     Educated   White            d--T\n6988     Educated   White     d--Deletion\n6989     Educated   White            d--D\n```\n\n\n:::\n:::\n\n\n### Types of Data\n\nThere are other types of data beside `numerical` (like `YOB` in the `td` data) and `character` (like all other columns in the `td` data).\n\n\\begin{table}\n\\caption{Types of data in \\textit{R}}\n\\begin{tabular}{lp{.33\\textwidth}p{.33\\textwidth}}\n\\toprule\n Data Type & Description & Example\\\\                                                                  \\texttt{logical} & either \\texttt{TRUE} or \\texttt{FALSE} & The answer to a question like \"is \\texttt{x} a number?\", etc.\\\\       \n \\texttt{numeric} & any real number, positive or negative, with or without decimal values & Vowel formant measurements, position in an audio file, household income, etc.\\\\ \n\\texttt{double}& any real number, positive or negative, with or without decimal values (identical to \\texttt{numeric}) & Vowel formant measurements, position in an audio file, household income, etc.\\\\\n\\texttt{integer}& whole numbers and their negative counterparts & year of birth, year of data collection, number of occurrences of something, etc.\\\\\n\\texttt{complex} & data that includes imaginary or unknown elements & the pythagorian theroem, i.e., $a^2 + b^2 = c^2$, where $a$, $b$, and $c$ are unknown\\\\\n\\texttt{character} & single characters (like \\texttt{'F'}) or \\textbf{strings} (like \\texttt{\"female\"}) & gender, speaker name, etc.\\\\ \n\\texttt{raw} & raw bytes  & Anything expressed in bytes \\\\\n\\end{tabular}\n\\end{table}\n::: callout-note\nCharacter data is always enclosed in either single quotes `' '` or double quotes `\" \"`. It is common practice to use single quotes for single characters and double quotes for strings, though either type of quotation marks will work with either data type.\n\n`double` is short for \"double precision floating point numbers\". Don't worry about the difference between `numeric` and `double`, because it doesn't really matter.\n:::\n\nIt is uncommon to use `raw` data in sociolinguistics. Anything can be expressed in bytes. There are two functions to convert from characters to bytes, and bytes to characters. To go from characters to bytes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_variable <- charToRaw(\"Sociolinguistics is fun\")\nprint(raw_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 53 6f 63 69 6f 6c 69 6e 67 75 69 73 74 69 63 73 20 69 73 20 66 75 6e\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(class(raw_variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"raw\"\n```\n\n\n:::\n:::\n\n\nAbove the function `charToRaw()` converts the string `\"Sociolinguistics is fun\"` to bytes and assigns that raw data to the object `raw_variable`. Next the `print()` function displays in *R* the contents of the variable `raw_variable`. The `class()` function returns the type of data contained within a variable. To convert back to characters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n char_variable <- rawToChar(raw_variable)\nprint(char_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sociolinguistics is fun\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(class(char_variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n### Types of Data Structures\n\nA **vector** and a **list** are the most basic types of data structures. A **vector** is a collection of elements, most commonly a collection of `character`, `logical`, `integer`, or `numeric` values. Values can be combined into a vector using the concatenating function `c()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple.vector <- c(\"Labov\", \"Fishman\")\nprint(simple.vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Labov\"   \"Fishman\"\n```\n\n\n:::\n:::\n\n\nWe can explore the vector using some of the same functions we've already seen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(simple.vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(simple.vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(simple.vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:2] \"Labov\" \"Fishman\"\n```\n\n\n:::\n:::\n\n\n**Lists** are like **vectors** but can contain a mixture of different data types. Characters must be in quotation marks. Numbers in quotation marks will be categorized as characters. Numeric data is numbers without quotation marks. Integers are specificed by adding `L` after the number. Logical values are either `TRUE` or `FALSE` in all capital letters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple.list<-list(\"Labov\", \"Fishman\",\"2001\", 1963, 1.5, 1974L, TRUE)\nprint(simple.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"Labov\"\n\n[[2]]\n[1] \"Fishman\"\n\n[[3]]\n[1] \"2001\"\n\n[[4]]\n[1] 1963\n\n[[5]]\n[1] 1.5\n\n[[6]]\n[1] 1974\n\n[[7]]\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(simple.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(simple.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(simple.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 7\n $ : chr \"Labov\"\n $ : chr \"Fishman\"\n $ : chr \"2001\"\n $ : num 1963\n $ : num 1.5\n $ : int 1974\n $ : logi TRUE\n```\n\n\n:::\n:::\n\n\nYou will notice that the results of the `str()` function show that `Labov`, `Fishman` and `2001` are all categorized as `chr` (character); `1963` and `1.5` are categorized as `num` (numeric); `1974` is categorized as `int` (integer); and `TRUE` is categorized as `logi` (logical).\n\nLists can be bigger than just one group of data. Items in a list can also be more complex than a single value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplex.list <- list(a = \"John Baugh\", b = simple.vector, c=simple.list, d=head(td))\nprint(complex.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] \"John Baugh\"\n\n$b\n[1] \"Labov\"   \"Fishman\"\n\n$c\n$c[[1]]\n[1] \"Labov\"\n\n$c[[2]]\n[1] \"Fishman\"\n\n$c[[3]]\n[1] \"2001\"\n\n$c[[4]]\n[1] 1963\n\n$c[[5]]\n[1] 1.5\n\n$c[[6]]\n[1] 1974\n\n$c[[7]]\n[1] TRUE\n\n\n$d\n   Dep.Var   Stress Category Morph.Type Before After Speaker  YOB Sex\n1 Realized Stressed Function       Mono  Vowel Pause  BOUF65 1965   F\n2 Realized Stressed Function       Mono  Vowel Pause  CHIF55 1955   F\n3 Realized Stressed Function       Mono  Vowel Pause  CLAF52 1952   F\n4 Deletion Stressed Function       Mono  Vowel Pause  CLAM73 1973   M\n5 Realized Stressed Function       Mono  Vowel Pause  DONF15 1915   F\n6 Realized Stressed Function       Mono  Vowel Pause  DONM41 1941   M\n     Education     Job Phoneme.Dep.Var\n1     Educated   White    t--Affricate\n2     Educated   White    t--Fricative\n3     Educated Service    t--Affricate\n4 Not Educated    Blue     t--Deletion\n5 Not Educated Service    t--Fricative\n6 Not Educated    Blue    t--Fricative\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(complex.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ a: chr \"John Baugh\"\n $ b: chr [1:2] \"Labov\" \"Fishman\"\n $ c:List of 7\n  ..$ : chr \"Labov\"\n  ..$ : chr \"Fishman\"\n  ..$ : chr \"2001\"\n  ..$ : num 1963\n  ..$ : num 1.5\n  ..$ : int 1974\n  ..$ : logi TRUE\n $ d:'data.frame':\t6 obs. of  12 variables:\n  ..$ Dep.Var        : chr [1:6] \"Realized\" \"Realized\" \"Realized\" \"Deletion\" ...\n  ..$ Stress         : chr [1:6] \"Stressed\" \"Stressed\" \"Stressed\" \"Stressed\" ...\n  ..$ Category       : chr [1:6] \"Function\" \"Function\" \"Function\" \"Function\" ...\n  ..$ Morph.Type     : chr [1:6] \"Mono\" \"Mono\" \"Mono\" \"Mono\" ...\n  ..$ Before         : chr [1:6] \"Vowel\" \"Vowel\" \"Vowel\" \"Vowel\" ...\n  ..$ After          : chr [1:6] \"Pause\" \"Pause\" \"Pause\" \"Pause\" ...\n  ..$ Speaker        : chr [1:6] \"BOUF65\" \"CHIF55\" \"CLAF52\" \"CLAM73\" ...\n  ..$ YOB            : int [1:6] 1965 1955 1952 1973 1915 1941\n  ..$ Sex            : chr [1:6] \"F\" \"F\" \"F\" \"M\" ...\n  ..$ Education      : chr [1:6] \"Educated\" \"Educated\" \"Educated\" \"Not Educated\" ...\n  ..$ Job            : chr [1:6] \"White\" \"White\" \"Service\" \"Blue\" ...\n  ..$ Phoneme.Dep.Var: chr [1:6] \"t--Affricate\" \"t--Fricative\" \"t--Affricate\" \"t--Deletion\" ...\n```\n\n\n:::\n:::\n\n\nIn the list `complex.list` column `a` contains only one value: `John Baugh`. Column `b` contains our `simple.vector`, column `c` contains our `simple.list`, and column `d` includes the first six rows of the `td` data (which itself has columns). To access the values from columns within columns you can use multiple `$` operators.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(complex.list$a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"John Baugh\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(complex.list$d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Dep.Var   Stress Category Morph.Type Before After Speaker  YOB Sex\n1 Realized Stressed Function       Mono  Vowel Pause  BOUF65 1965   F\n2 Realized Stressed Function       Mono  Vowel Pause  CHIF55 1955   F\n3 Realized Stressed Function       Mono  Vowel Pause  CLAF52 1952   F\n4 Deletion Stressed Function       Mono  Vowel Pause  CLAM73 1973   M\n5 Realized Stressed Function       Mono  Vowel Pause  DONF15 1915   F\n6 Realized Stressed Function       Mono  Vowel Pause  DONM41 1941   M\n     Education     Job Phoneme.Dep.Var\n1     Educated   White    t--Affricate\n2     Educated   White    t--Fricative\n3     Educated Service    t--Affricate\n4 Not Educated    Blue     t--Deletion\n5 Not Educated Service    t--Fricative\n6 Not Educated    Blue    t--Fricative\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(complex.list$d$Job)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"White\"   \"White\"   \"Service\" \"Blue\"    \"Service\" \"Blue\"   \n```\n\n\n:::\n:::\n\n\nGenerally, in LVC analysis we do not deal often with either simple vectors or lists; instead, most of our data is in a spreadsheet-like format, which in *R* is a **data frame**.\n\n**Data frames** are a special type of **list** in which every element in the **list** has the same length (unlike, for example, the `complex.list` above). **Data frames** can have additional annotations, like `rownames()`. Some statisticians use `rownames()` for things like `participantID`, `sampleID`, or some other unique identifier. Most of the time (and for our purposes), `rownames()` are not useful given that we have multiple rows from the same speaker/interview, etc.\n\n### Factors and Comments\n\nA *factor* in *R* is a special type of variable or data type that, in theory, has a limited number of values. Each value is called a *level*. Any **vector** or **data frame** column of `character` or `integer` values can be a **factor**. Most non-numerical data in LVC is generally thought of as a **factor** already, so knowing how to convert **vectors** or **data frame** columns to factors is important. For example, in the `td` data, the column `Stress` contains only two options: `Stressed` and `Unstressed`. Because this column contains letters, when we imported it into *R*, it was automatically categorized as `character` data. This is probably the best option for a column that, for example, contained the broader context of a token. For `Stress`, however, it is better for our purposes for *R* to consider the column as containing a **factor** with two discrete levels. Below is the code to convert `Stress` into a **factor**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determine the class of the column Stress in the date frame td\nclass(td$Stress)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert Stress to a column to a factor\ntd$Stress <-factor(td$Stress)\n# Verify class of Stress column\nclass(td$Stress)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\nNotice the **comments** in the code above. In *R* any line that begins with a `#` is not evaluated. This is called *commenting out* a line. We use `#` to include notes in our codes, or to keep code in our script file but have *R* ignore it. This can be useful in order to keep track of the steps you are taking in an analysis (see also [this tutorial](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections-in-the-RStudio-IDE) on organizing code using `#`)\n\nColumns within a data frame can be specified using the `$` operator So, above, we tell *R* to assign (using the assignment operator `<-`) the values of the original `td$Stress` column, converted into **factors**, back to the column `td$Stress`. In other words, we are replacing the original column `td$Stress` with a converted version of itself. Now, look how the output of the `summary()` function changes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Dep.Var                 Stress       Category          Morph.Type       \n Length:6989        Stressed  :6555   Length:6989        Length:6989       \n Class :character   Unstressed: 434   Class :character   Class :character  \n Mode  :character                     Mode  :character   Mode  :character  \n                                                                           \n                                                                           \n                                                                           \n    Before             After             Speaker               YOB      \n Length:6989        Length:6989        Length:6989        Min.   :1915  \n Class :character   Class :character   Class :character   1st Qu.:1952  \n Mode  :character   Mode  :character   Mode  :character   Median :1965  \n                                                          Mean   :1967  \n                                                          3rd Qu.:1991  \n                                                          Max.   :1999  \n     Sex             Education             Job            Phoneme.Dep.Var   \n Length:6989        Length:6989        Length:6989        Length:6989       \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n```\n\n\n:::\n:::\n\n\nWe get the number of observations of each level of `td$Stress` instead of just the number of rows (i.e. the `length` of the column).\n\nTo get the levels of a **factor** we can use the function `levels()` and to get the number of levels, we can use the function `nlevels()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(td$Stress)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Stressed\"   \"Unstressed\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnlevels(td$Stress)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## More Exploring\n\nIf you only want information from a single column of the data frame, you can use the operator `$` to specify which column of `td` you want. Here the column \\`Sex' is specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(td$Sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n     6989 character character \n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(td$Sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\nThe `Sex` column is still categorized as `character` data and so `summary()` only return the number of rows (`length`) of the column and there are no levels. To get the information we want about the `Sex` column (i.e., how many tokens are from male speakers and how many are from women speakers) we need to convert it to a factor first. We can either convert the the column to a factor column, or we can use the `as.factor()` function to have *R* treat is as a factor in just the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(as.factor(td$Sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   F    M \n3776 3213 \n```\n\n\n:::\n\n```{.r .cell-code}\nlevels (as.factor(td$Sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"F\" \"M\"\n```\n\n\n:::\n:::\n\n\nThe following code changes all the character class columns to factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start with a fresh import of the (t, d) data into R, downloading it directly\ntd <-read.delim(\"https://www.dropbox.com/s/jxlfuogea3lx2pu/deletiondata.txt?dl=1\")\n\n# or using the version saved locally in a folder Data in the same location as your script file\ntd <- read.delim(\"Data/deletiondata.txt\")\n\n# Now convert each character column into a factor\ntd$Dep.Var <- factor(td$Dep.Var)\ntd$Stress <- factor(td$Stress)\ntd$Category <- factor(td$Category)\ntd$Morph.Type<- factor(td$Morph.Type)\ntd$Before <- factor(td$Before)\ntd$After <- factor(td$After)\ntd$Speaker <- factor(td$Speaker)\ntd$Sex <- factor(td$Sex)\ntd$Education <- factor(td$Education)\ntd$Job <- factor(td$Job)\ntd$Phoneme.Dep.Var <- factor(td$Phoneme.Dep.Var)\n```\n:::\n\n\n## The (t/d) Data\n\nLet's look at the data now that all the character columns are factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(td)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Dep.Var            Stress         Category        Morph.Type  \n Deletion:1747   Stressed  :6555   Function: 739   Mono     :5236  \n Realized:5242   Unstressed: 434   Lexical :6250   Past     : 782  \n                                                   Semi-Weak: 971  \n                                                                   \n                                                                   \n                                                                   \n                                                                   \n             Before           After         Speaker          YOB       Sex     \n Liquid         : 269   Consonant: 709   GARF87 : 224   Min.   :1915   F:3776  \n Nasal          : 209   H        : 246   INGM84 : 212   1st Qu.:1952   M:3213  \n Other Fricative: 130   Pause    :5248   MARM92 : 176   Median :1965           \n S              : 332   Vowel    : 786   HANF83 : 139   Mean   :1967           \n Stop           : 249                    CHIF55 : 135   3rd Qu.:1991           \n Vowel          :5800                    GARF16 : 132   Max.   :1999           \n                                         (Other):5971                          \n        Education         Job           Phoneme.Dep.Var\n Educated    :3006   Blue   :1068   t--Deletion : 981  \n Not Educated:2184   Service:2895   t--Fricative: 973  \n Student     :1799   Student:1799   t--T        : 830  \n                     White  :1227   d--Deletion : 766  \n                                    t--Affricate: 667  \n                                    d--T        : 583  \n                                    (Other)     :2189  \n```\n\n\n:::\n:::\n\n\nAs shown by the `summary(td)` results above, the first column in the (t, d) deletion data is called `Dep.Var` and it includes two levels: `Realized` and `Deletion`. These two levels represent the two options for each token of (t, d). The values after each level are how many rows are coded with that level. In other words, there are 1,747 rows (or tokens) of `Deletion` and there are 5,242 rows (or tokens) of `Realized`. Notice that the order of the factor levels is alphabetical. There is a column labelled `Stress` which indicates if the (t, d) token is in a stressed or unstressed syllable. The `Category` column indicates if the word in which the (t, d) token appears is a function or lexical word. `Morph.Type` indicates if the (t, d) occurs in a monomorpheme (like *fist*), a semi-weak simple past-tense verb (like *dealt* ) in which there is a vowel change and a (t,d) sound is added, or a weak simple past-tense verb (like *walked*) in which just /*-ed*/ is added. `Before` indicates the type of sound preceding the (t, d) and `After` indicates the sound following the (t, d). `Speaker` is a unique identifier for each participant in the data (only the first six are displayed, though); `YOB` indicates the speaker's year of birth, `Sex` his or her sex[^1], `Education` his or her education level, and `Job` his or her job type. Finally, `Phoneme.Dep.Var` indicates the canonical underlying phoneme of the (t, d) token and a more detailed coding of the dependent variable.\n\n[^1]: These were the only two sex/gender identities reported by speakers in this data.\n",
    "supporting": [
      "030_lvcr_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}