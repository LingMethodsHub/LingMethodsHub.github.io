{
  "hash": "7e8aac094a1389102ecfec6c0db26c96",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crosstabs: Counts, Proportions, and More\"\ndate: \"2022-9-27\"\nlicense: \"CC-BY-SA 4.0\"\ndescription: \"Getting token counts and proportions. Getting mean, median, standard deviation, and quartiles. Dealing with decimals and exponential notation. \"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nIt took me two years to figure out how to do cross-tabs in *R* the way that *Goldvarb* does cross-tabs. Below I show you how to build cross-tabs from scratch.\n\n## Token Counts\n\nA good starting point is the function `table()`. This function returns token numbers.\n\n:::{.content-visible when-format=\"html\"}\n\n::: {.callout-tip}\n## Get the data first\nIf you don't have the `td` data loaded in *R*, go back to [Doing it all again, but `tidy`](https://lingmethodshub.github.io/content/R/lvc_r/050_lvcr.html) and run the code.\n:::\n:::\n\n\n:::{.content-visible when-format=\"pdf\"}\n\n::: {.callout-tip}\n## Get the data first\nIf you don't have the `td` data loaded in *R*, go back to [Doing it all again, but `tidy`](https://lingmethodshub.github.io/content/R/lvc_r/050_lvcr.html) and run the code.\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by level of Dep.Var\ntable(td$Dep.Var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nDeletion Realized \n     386      803 \n```\n\n\n:::\n:::\n\n\nThis tells you that there are 386 `Deletion` tokens and 803 not deleted, or `Realized` tokens. If you add another factor group like `Age.Group`, you get the number of tokens for each level of `Dep.Var` for each level of that additional factor group. These two factor groups are returned as the rows and then columns in the table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by level of Dep.Var and Age.Group\ntable(td$Dep.Var, td$Age.Group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          \n           Old Middle Young\n  Deletion  67    125   194\n  Realized 134    235   434\n```\n\n\n:::\n:::\n\n\nIf you add one more factor group, `Sex`, it divides the data in what *R* calls \"pages\". The first page is the number of tokens for each level of `Dep.Var` by each level of `Age.Group` for female data (`Sex = F`), and then the same for the male data (`Sex = M`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Dep.Var, Sex, and Age.Group\ntable(td$Dep.Var, td$Age.Group, td$Sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style=\"max-height: 500px;\"}\n, ,  = F\n\n          \n           Old Middle Young\n  Deletion  43     73    72\n  Realized 107    165   199\n\n, ,  = M\n\n          \n           Old Middle Young\n  Deletion  24     52   122\n  Realized  27     70   235\n```\n\n\n:::\n:::\n\n\nYou can add the option `deparse.level = 2` to include the names of the columns in the table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Dep.Var, Sex, and Age.Group\ntable(td$Dep.Var, td$Age.Group, td$Sex, deparse.level = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style=\"max-height: 500px;\"}\n, , td$Sex = F\n\n          td$Age.Group\ntd$Dep.Var Old Middle Young\n  Deletion  43     73    72\n  Realized 107    165   199\n\n, , td$Sex = M\n\n          td$Age.Group\ntd$Dep.Var Old Middle Young\n  Deletion  24     52   122\n  Realized  27     70   235\n```\n\n\n:::\n:::\n\n\nIf you wrap the `table()` function in the `addmargins()` function you get the sums of each row and column, and another page for both the male and the female data together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Dep.Var, Sex, and Age.Group, with column, row and page totals\naddmargins(table(td$Dep.Var, td$Age.Group, td$Sex,  deparse.level = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style=\"max-height: 500px;\"}\n, , td$Sex = F\n\n          td$Age.Group\ntd$Dep.Var  Old Middle Young  Sum\n  Deletion   43     73    72  188\n  Realized  107    165   199  471\n  Sum       150    238   271  659\n\n, , td$Sex = M\n\n          td$Age.Group\ntd$Dep.Var  Old Middle Young  Sum\n  Deletion   24     52   122  198\n  Realized   27     70   235  332\n  Sum        51    122   357  530\n\n, , td$Sex = Sum\n\n          td$Age.Group\ntd$Dep.Var  Old Middle Young  Sum\n  Deletion   67    125   194  386\n  Realized  134    235   434  803\n  Sum       201    360   628 1189\n```\n\n\n:::\n:::\n\n\nIf you change the order of factor groups you include in the `table()` function you can change which factors are rows, which are columns, and which are pages. You can also keep adding factors as additional pages. The order is always: rows, columns, page 1, page 2, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Age.Group, Education, Sex, and Dep.Var, with row, column, and page totals \naddmargins(table(td$Age.Group, td$Education, td$Sex, td$Dep.Var,  deparse.level = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style=\"max-height: 500px;\"}\n, , td$Sex = F, td$Dep.Var = Deletion\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old           2           41       0   43\n      Middle       68            5       0   73\n      Young        20            0      52   72\n      Sum          90           46      52  188\n\n, , td$Sex = M, td$Dep.Var = Deletion\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old           0           24       0   24\n      Middle       16           36       0   52\n      Young        48           24      50  122\n      Sum          64           84      50  198\n\n, , td$Sex = Sum, td$Dep.Var = Deletion\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old           2           65       0   67\n      Middle       84           41       0  125\n      Young        68           24     102  194\n      Sum         154          130     102  386\n\n, , td$Sex = F, td$Dep.Var = Realized\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old          30           77       0  107\n      Middle      153           12       0  165\n      Young        52            0     147  199\n      Sum         235           89     147  471\n\n, , td$Sex = M, td$Dep.Var = Realized\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old           0           27       0   27\n      Middle       30           40       0   70\n      Young        77           31     127  235\n      Sum         107           98     127  332\n\n, , td$Sex = Sum, td$Dep.Var = Realized\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old          30          104       0  134\n      Middle      183           52       0  235\n      Young       129           31     274  434\n      Sum         342          187     274  803\n\n, , td$Sex = F, td$Dep.Var = Sum\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old          32          118       0  150\n      Middle      221           17       0  238\n      Young        72            0     199  271\n      Sum         325          135     199  659\n\n, , td$Sex = M, td$Dep.Var = Sum\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old           0           51       0   51\n      Middle       46           76       0  122\n      Young       125           55     177  357\n      Sum         171          182     177  530\n\n, , td$Sex = Sum, td$Dep.Var = Sum\n\n            td$Education\ntd$Age.Group Educated Not Educated Student  Sum\n      Old          32          169       0  201\n      Middle      267           93       0  360\n      Young       197           55     376  628\n      Sum         496          317     376 1189\n```\n\n\n:::\n:::\n\n\nThe above function produces 9 \"pages\", one for each combination of `Sex` (two levels) and `Dep.Var` (two levels), plus the sum of each (one additional level each), and the sum for both. With more than three factor groups like this it is very useful to have the column names included in the output. Scroll to the sixth page, for example (the one that begins `, , td$Sex = Sum, td$Dep.Var = Realized`). It shows the number of tokens by `Age.Group` and `Education` (the first two factor groups in the function), when `Sex` equals `Sum` (e.g., `M` and `F` combined) and `Dep.Var` equals `Realized`.\n\nOne advantage of doing cross-tabs in *R*, rather than *Goldvarb*, is that you can simultaneously cross more than two factor groups at once. But, the presentation of these factors in pages may not be the most useful. The function `ftable()` in the package `vcd` presents the cross-tab in a more condensed format. The last factor group in the `table()` function will be the variable for the columns in `ftable()`, so you always want to make that the dependent variable. Below is the `ftable()` for the cross-tab of `Age.Group`, `Education`, `Sex`, and `Dep.Var`. You can see, for example, that there are 52 `Deletion` tokens from young, student, female speakers and that there are no tokens from old, educated men.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Age.Group, Education, Sex, and Dep.Var, with row, column and page totals, presented in a flattened table\nlibrary(vcd)\nftable(table(td$Age.Group, td$Education, td$Sex, td$Dep.Var))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                       Deletion Realized\n                                        \nOld    Educated     F         2       30\n                    M         0        0\n       Not Educated F        41       77\n                    M        24       27\n       Student      F         0        0\n                    M         0        0\nMiddle Educated     F        68      153\n                    M        16       30\n       Not Educated F         5       12\n                    M        36       40\n       Student      F         0        0\n                    M         0        0\nYoung  Educated     F        20       52\n                    M        48       77\n       Not Educated F         0        0\n                    M        24       31\n       Student      F        52      147\n                    M        50      127\n```\n\n\n:::\n\n```{.r .cell-code}\n# Do the same but include the margin values\nftable(addmargins(table(td$Age.Group, td$Education, td$Sex, td$Dep.Var)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         Deletion Realized  Sum\n                                               \nOld    Educated     F           2       30   32\n                    M           0        0    0\n                    Sum         2       30   32\n       Not Educated F          41       77  118\n                    M          24       27   51\n                    Sum        65      104  169\n       Student      F           0        0    0\n                    M           0        0    0\n                    Sum         0        0    0\n       Sum          F          43      107  150\n                    M          24       27   51\n                    Sum        67      134  201\nMiddle Educated     F          68      153  221\n                    M          16       30   46\n                    Sum        84      183  267\n       Not Educated F           5       12   17\n                    M          36       40   76\n                    Sum        41       52   93\n       Student      F           0        0    0\n                    M           0        0    0\n                    Sum         0        0    0\n       Sum          F          73      165  238\n                    M          52       70  122\n                    Sum       125      235  360\nYoung  Educated     F          20       52   72\n                    M          48       77  125\n                    Sum        68      129  197\n       Not Educated F           0        0    0\n                    M          24       31   55\n                    Sum        24       31   55\n       Student      F          52      147  199\n                    M          50      127  177\n                    Sum       102      274  376\n       Sum          F          72      199  271\n                    M         122      235  357\n                    Sum       194      434  628\nSum    Educated     F          90      235  325\n                    M          64      107  171\n                    Sum       154      342  496\n       Not Educated F          46       89  135\n                    M          84       98  182\n                    Sum       130      187  317\n       Student      F          52      147  199\n                    M          50      127  177\n                    Sum       102      274  376\n       Sum          F         188      471  659\n                    M         198      332  530\n                    Sum       386      803 1189\n```\n\n\n:::\n:::\n\n\nOf course we can use the pipe `%>%` to make things a bit easier\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the number of tokens by Age.Group, Education, Sex, and Dep.Var, with row, column and page totals, presented in a flattened table\ntable(td$Age.Group, td$Education, td$Sex, td$Dep.Var) %>% \n  addmargins() %>% \n  ftable()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         Deletion Realized  Sum\n                                               \nOld    Educated     F           2       30   32\n                    M           0        0    0\n                    Sum         2       30   32\n       Not Educated F          41       77  118\n                    M          24       27   51\n                    Sum        65      104  169\n       Student      F           0        0    0\n                    M           0        0    0\n                    Sum         0        0    0\n       Sum          F          43      107  150\n                    M          24       27   51\n                    Sum        67      134  201\nMiddle Educated     F          68      153  221\n                    M          16       30   46\n                    Sum        84      183  267\n       Not Educated F           5       12   17\n                    M          36       40   76\n                    Sum        41       52   93\n       Student      F           0        0    0\n                    M           0        0    0\n                    Sum         0        0    0\n       Sum          F          73      165  238\n                    M          52       70  122\n                    Sum       125      235  360\nYoung  Educated     F          20       52   72\n                    M          48       77  125\n                    Sum        68      129  197\n       Not Educated F           0        0    0\n                    M          24       31   55\n                    Sum        24       31   55\n       Student      F          52      147  199\n                    M          50      127  177\n                    Sum       102      274  376\n       Sum          F          72      199  271\n                    M         122      235  357\n                    Sum       194      434  628\nSum    Educated     F          90      235  325\n                    M          64      107  171\n                    Sum       154      342  496\n       Not Educated F          46       89  135\n                    M          84       98  182\n                    Sum       130      187  317\n       Student      F          52      147  199\n                    M          50      127  177\n                    Sum       102      274  376\n       Sum          F         188      471  659\n                    M         198      332  530\n                    Sum       386      803 1189\n```\n\n\n:::\n:::\n\n\nAnother `tidy` way to find out the number of tokens by the different levels of a factor group is using the `group_by()` and `tally()` functions. First, we specify how to group the data, i.e., what combination of factors we want to investigate. In this case, we want the number of tokens for every combination of `Age.Group`, `Education`, `Sex` and `Dep.Var`. Next we use the `tally()` function to provide the token counts for each of those combinations. The results are very similar to those produced by `ftable(table())`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by Age, Education, and Sex then tally each group\ntd %>% \n  group_by(Age.Group, Education, Sex, Dep.Var) %>%\n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 5\n# Groups:   Age.Group, Education, Sex [12]\n   Age.Group Education    Sex   Dep.Var      n\n   <fct>     <fct>        <fct> <fct>    <int>\n 1 Old       Educated     F     Deletion     2\n 2 Old       Educated     F     Realized    30\n 3 Old       Not Educated F     Deletion    41\n 4 Old       Not Educated F     Realized    77\n 5 Old       Not Educated M     Deletion    24\n 6 Old       Not Educated M     Realized    27\n 7 Middle    Educated     F     Deletion    68\n 8 Middle    Educated     F     Realized   153\n 9 Middle    Educated     M     Deletion    16\n10 Middle    Educated     M     Realized    30\n# ℹ 14 more rows\n```\n\n\n:::\n:::\n\n\nAs the results of `tally()` is a *tibble*, only the first 10 rows will be printed. To print all the rows add `print(n=Inf)` at the end.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by Age, Education, and Sex, tally each group, then print all rows\ntd %>% \n  group_by(Age.Group, Education, Sex, Dep.Var) %>% \n  tally() %>%\n  print(n=Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 5\n# Groups:   Age.Group, Education, Sex [12]\n   Age.Group Education    Sex   Dep.Var      n\n   <fct>     <fct>        <fct> <fct>    <int>\n 1 Old       Educated     F     Deletion     2\n 2 Old       Educated     F     Realized    30\n 3 Old       Not Educated F     Deletion    41\n 4 Old       Not Educated F     Realized    77\n 5 Old       Not Educated M     Deletion    24\n 6 Old       Not Educated M     Realized    27\n 7 Middle    Educated     F     Deletion    68\n 8 Middle    Educated     F     Realized   153\n 9 Middle    Educated     M     Deletion    16\n10 Middle    Educated     M     Realized    30\n11 Middle    Not Educated F     Deletion     5\n12 Middle    Not Educated F     Realized    12\n13 Middle    Not Educated M     Deletion    36\n14 Middle    Not Educated M     Realized    40\n15 Young     Educated     F     Deletion    20\n16 Young     Educated     F     Realized    52\n17 Young     Educated     M     Deletion    48\n18 Young     Educated     M     Realized    77\n19 Young     Not Educated M     Deletion    24\n20 Young     Not Educated M     Realized    31\n21 Young     Student      F     Deletion    52\n22 Young     Student      F     Realized   147\n23 Young     Student      M     Deletion    50\n24 Young     Student      M     Realized   127\n```\n\n\n:::\n:::\n\n\nThe above code gives us the number of `Realized` and `Deletion` tokens for each combination of `Age.Group`, `Education`, and `Sex`. What if we want the total number of tokens for each combination, rather than the number of each level of `Dep.Var`. In this case, you can just drop `Dep.Var` from the `group_by()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get total number of tokens per group by removing Dep.Var\ntd %>% \n  group_by(Age.Group, Education, Sex) %>% \n  tally() %>%\n  print(n=Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n# Groups:   Age.Group, Education [7]\n   Age.Group Education    Sex       n\n   <fct>     <fct>        <fct> <int>\n 1 Old       Educated     F        32\n 2 Old       Not Educated F       118\n 3 Old       Not Educated M        51\n 4 Middle    Educated     F       221\n 5 Middle    Educated     M        46\n 6 Middle    Not Educated F        17\n 7 Middle    Not Educated M        76\n 8 Young     Educated     F        72\n 9 Young     Educated     M       125\n10 Young     Not Educated M        55\n11 Young     Student      F       199\n12 Young     Student      M       177\n```\n\n\n:::\n:::\n\n\nWe know now that there are 32 tokens from `Old`, `Educated`, `F` (female) speakers. The previous `tally()` shows us that 2 of the tokens are `Deletion` and 30 are of `Realized`.\n\nAn alternative to `tally()` is the much more flexible `summarize()` function.[^2] With this function you can apply a summary statistic function to each combination of the grouping variables. If no summary statistic function is created, the a tibble of the combination of the groups is produced.\n\n[^2]: `summarise()` and `summarize()` are synonyms.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a tibble of all combinations of Age.Group, Education, and Sex (for which there are rows of data)\ntd %>%\n  group_by(Age.Group, Education, Sex) %>%\n  summarize()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n# Groups:   Age.Group, Education [7]\n   Age.Group Education    Sex  \n   <fct>     <fct>        <fct>\n 1 Old       Educated     F    \n 2 Old       Not Educated F    \n 3 Old       Not Educated M    \n 4 Middle    Educated     F    \n 5 Middle    Educated     M    \n 6 Middle    Not Educated F    \n 7 Middle    Not Educated M    \n 8 Young     Educated     F    \n 9 Young     Educated     M    \n10 Young     Not Educated M    \n11 Young     Student      F    \n12 Young     Student      M    \n```\n\n\n:::\n:::\n\n\nTo get the count, or number of rows, of each combination, we create a new column in the tibble that is the output of `summarize()` and assign to it the value of the count function `n()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a tibble of grouping variables, then add a new column \"Tokens\" with the value of the count function \ntd %>%\n  group_by(Age.Group, Education, Sex, Dep.Var) %>%\n  summarize(Tokens = n()) %>% \n  print(n = Inf) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 5\n# Groups:   Age.Group, Education, Sex [12]\n   Age.Group Education    Sex   Dep.Var  Tokens\n   <fct>     <fct>        <fct> <fct>     <int>\n 1 Old       Educated     F     Deletion      2\n 2 Old       Educated     F     Realized     30\n 3 Old       Not Educated F     Deletion     41\n 4 Old       Not Educated F     Realized     77\n 5 Old       Not Educated M     Deletion     24\n 6 Old       Not Educated M     Realized     27\n 7 Middle    Educated     F     Deletion     68\n 8 Middle    Educated     F     Realized    153\n 9 Middle    Educated     M     Deletion     16\n10 Middle    Educated     M     Realized     30\n11 Middle    Not Educated F     Deletion      5\n12 Middle    Not Educated F     Realized     12\n13 Middle    Not Educated M     Deletion     36\n14 Middle    Not Educated M     Realized     40\n15 Young     Educated     F     Deletion     20\n16 Young     Educated     F     Realized     52\n17 Young     Educated     M     Deletion     48\n18 Young     Educated     M     Realized     77\n19 Young     Not Educated M     Deletion     24\n20 Young     Not Educated M     Realized     31\n21 Young     Student      F     Deletion     52\n22 Young     Student      F     Realized    147\n23 Young     Student      M     Deletion     50\n24 Young     Student      M     Realized    127\n```\n\n\n:::\n:::\n\n\nThe `summarize()` function can be used with a number of summary statistic functions, including, but not limited to, the following:\n\n| Type     | Some Useful Functions        |\n|----------|------------------------------|\n| Center   | `mean()`, `median()`         |\n| Spread   | `sd()`, `IQR()`              |\n| Range    | `min()`, `max()`             |\n| Position | `first()`, `last()`, `nth()` |\n| Count    | `n()`, `n_distinct()`        |\n| Logical  | `any()`, `all()`             |\n\n## Summary Statistics for Continous Variables\n\nThis seems like an appropriate place to describe how to summarize values that are continous, like `YOB`. Normally in variationist sociolinguistics we are very concerned with frequency and proportion of usage, and we will explore how to generate those statistics in the following section. Here, however, let's explore the functions available to use inside `summarize()`. These functions can be used on their own, also. For example, the first two, `mean()` and `median()` provide the arithmetic mean (basically the average) of a set of numbers while the `median()` provides the exact middle number of a set of values organized from smallest to largest (if there are an even number of values, `median()` returns the halfway point between the two middle numbers).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get mean year of birth\nmean(td$YOB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1969.447\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get median year of birth\nmedian(td$YOB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1984\n```\n\n\n:::\n:::\n\n\nWe already know that the mean year of birth for the `td` data set is 1969.447. You can also see that the middle number of all years of birth organized from oldest to youngest is 1984. If we wanted to find the mean or median year of birth for either just male or just female speakers, we have two options. We can use the base filter technique, or we can use the `tidy` method to group the data and summarize it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get mean year of birth of just female speakers\nmean(td$YOB[td$Sex == \"F\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1963.487\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get mean year of birth of just male speaker\nmean(td$YOB[td$Sex == \"M\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1976.857\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get mean year of birth for each level of Sex\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  Sex   Mean.YOB\n  <fct>    <dbl>\n1 F        1963.\n2 M        1977.\n```\n\n\n:::\n:::\n\n\n### Dealing with Decimals\n\n*Tibbles* are intended to be succinct and concise, so they provide very few values after the decimal place by default. If you require more decimal values, the easiest (trust me) thing to do is to convert the tibble into a *data frame*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get mean year of birth by Sex, converted to data frame \ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB)) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex Mean.YOB\n1   F 1963.487\n2   M 1976.857\n```\n\n\n:::\n:::\n\n\n*data frames* will display whole numbers, and numbers with decimals up to the total number of digits set by `options()` function. Keep in mind, though, that changing this value changes the global options for *R*. An alternative is to use the `format()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 6\noptions(digits = 6)\n# Get mean year of birth by sex, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB)) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex Mean.YOB\n1   F  1963.49\n2   M  1976.86\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 10\noptions(digits = 10)\n# Get mean year of birth by sex, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB)) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex    Mean.YOB\n1   F 1963.487102\n2   M 1976.856604\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 3\noptions(digits = 3)\n# Get mean year of birth by sex, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB)) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex Mean.YOB\n1   F     1963\n2   M     1977\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 3\noptions(digits = 3)\n# Get mean year of birth by sex, converted to data frame but showing 10 significant digits\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB)) %>%\n  as.data.frame() %>%\n  format(digits = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex    Mean.YOB\n1   F 1963.487102\n2   M 1976.856604\n```\n\n\n:::\n:::\n\n\nFor very large numbers *R* will often display values in exponential notation. We can alter this by setting the value of `scipen` inside the `option()` function. Again, though, remember that this is a global change for your whole *R* session. For `scipen` positive values increase the likelihood of using real numbers, negative values increase the likelihood of using exponential notation. To ensure printouts are always real numbers, set `scipen` to 9999 (this is the default). To ensure printouts are always exponential notation, set `scipen` to -9999. To demonstrate, below we multiply mean `YOB` by 10000.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 6, alter the likelihood of use of real number rather than scientific notation by 0\noptions(digits = 6, scipen = 0)\n# Get mean year of birth by sex multiplied by 100000, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB) * 100000) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex  Mean.YOB\n1   F 196348710\n2   M 197685660\n```\n\n\n:::\n:::\n\n\nWith `scipen` set to 0, we still get real numbers as the values `Mean.YOB` are not too big. To ensure we have real numbers, though, we change the `scipen` value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 6, alter the likelihood of use of real number rather than scientific notation by 9999\noptions(digits = 6, scipen = 9999)\n# Get mean year of birth by sex multiplied by 100000, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB) * 10000) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex Mean.YOB\n1   F 19634871\n2   M 19768566\n```\n\n\n:::\n:::\n\n\nIf, instead we prefer exponential notation, we use the maximum negative `scipen` value, -9999/\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 6, alter the likelihood of use of real number rather than scientific notation by -9999\noptions(digits = 6, scipen = -9999)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in options(digits = 6e+00, scipen = -9.999e+03): invalid 'scipen'\n-9999, used -9\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get mean year of birth by sex multiplied by 100000, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB) * 10000) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex    Mean.YOB\n1   F 1.96349e+07\n2   M 1.97686e+07\n```\n\n\n:::\n:::\n\n\nAbove, the value `1.96349e+07` means $1.96349 \\times 10^7$. The easiest way to calculate this is to simply move the decimal places 7 spaces to the right (as the exponent is positive), which gives `19634900`. Notice some precision is lost because our number of `digits` is only 6.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 10, alter the likelihood of use of real number rather than scientific notation by -9999\noptions(digits = 10, scipen = -9999)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in options(digits = 1e+01, scipen = -9.999e+03): invalid 'scipen'\n-9999, used -9\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get mean year of birth by sex multiplied by 100000, converted to data frame\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB) * 10000) %>%\n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex        Mean.YOB\n1   F 1.963487102e+07\n2   M 1.976856604e+07\n```\n\n\n:::\n:::\n\n\nNow, with more `digits` we have more precision; $1.963487102 \\times 10^7 = 19634671.02$. If the exponential values are negative, move the decimal place to the left. For example, $1.963487102 \\times 10^-7 = 0.0000001963467102$.\n\nSimilarly, we can set whether or not we want scientific notation using the `format()` function. The `scientific` option can be either `TRUE` or `FALSE`, or a value like `scipen`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change number of significant digits displayed to 3, alter the likelihood of use of real number rather than scientific notation by 9999\noptions(digits = 3, scipen = 9999)\n# Get mean year of birth by sex multiplied by 100000, converted to data frame, digits formatted to 10 significant digits, and exponential notation\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB) * 10000) %>%\n  as.data.frame() %>%\n  format(digits = 10, scientific = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex        Mean.YOB\n1   F 1.963487102e+07\n2   M 1.976856604e+07\n```\n\n\n:::\n:::\n\n\n## More Summary Statistics for Continous Variables\n\nThe other summary statistics for continuous variables include spread functions and the range functions. Some spread functions are `sd()`, which returns the standard deviation; and `IQR()` which returns the interquartile range.[^3] Some range functions include: `min()`, which returns the lowest value; `max()`, which returns the highest value. To find the maximum spread (from highest to lowest), we can either subtract the `min()` value from the `max()` value, or employ the `diff()` function plus the `range()` function (which produces a vector containing the minimum and maximum values).\n\n[^3]: If we order the data from lowest to highest values, 50% of the data will be less than the mean, and 50% of the data will be higher than the mean. The mean is also called the 2nd quartile. The first quartile is halfway between the mean and the lowest value in the data. The third quartile is halfway betwen the mean and the highest value in the data. The interquartile range is the difference between the 3rd quartile and the 1st quartile and represents the spread of the middle 50% of the data.\n\nWe can include these functions inside the same `summarize()` function as we used above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get mean, standard deviation, interquartile range, minimum value, maximum value, and range of values (twice) for year of birth\ntd %>%\n  group_by(Sex) %>%\n  summarize(Mean.YOB = mean(YOB), \n            SD.YOB = sd(YOB), \n            IQR.YOB = IQR(YOB), \n            Min.YOB = min(YOB), \n            Max.YOB = max(YOB), \n            Range = max(YOB) - min(YOB), \n            Range2 = diff(range(YOB)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 8\n  Sex   Mean.YOB SD.YOB IQR.YOB Min.YOB Max.YOB Range Range2\n  <fct>    <dbl>  <dbl>   <dbl>   <int>   <int> <int>  <int>\n1 F        1963.   26.5      45    1915    1999    84     84\n2 M        1977.   19.6      33    1921    1994    73     73\n```\n\n\n:::\n:::\n\n\nBased on these values, we can make the following statements:\n\n-   Among females in the (t, d) data, the average or mean year of birth is 1963 $\\pm$ 26.5 years.\n\n-   The oldest female speakers was born in 1915, and the youngest female speaker was born in 1999.\n\n-   Fifty-percent of women were born in the 45 years centered around 1963.\n\n-   The female data represents 84 years of [apparent time](https://en.wikipedia.org/wiki/Apparent-time_hypothesis).\n\n## Position functions with `summarize()`\n\nThe position functions `first()`, `last()`, and `nth()` also work on the data created by `group_by()` and `summarize()`. `first()` returns the first value, `last()` returns the last value, and `nth()` returns the value after a specific number of rows. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get first six rows of just Sex and Dep.Var columns of td\ntd %>%\n  select(Sex, Dep.Var) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sex  Dep.Var\n1   F Realized\n2   F Deletion\n3   F Deletion\n4   F Deletion\n5   M Realized\n6   M Deletion\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get last six rows of just Sex and Dep.Var columns of td\ntd %>%\n  select(Sex, Dep.Var) %>%\n  tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Sex  Dep.Var\n1184   F Realized\n1185   F Realized\n1186   F Realized\n1187   M Realized\n1188   M Deletion\n1189   M Realized\n```\n\n\n:::\n:::\n\n\nAbove we use the `select()` function to choose just the `Sex` and `Dep.Var` columns and run the `head()` and `tail()` functions in order to see the first and last six values for both in the data. We do this just for comparisons sake. Now, lets use the position functions an compare them to our results. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Get first, last, second, and second to last value of Dep.Var by Sex\ntd %>%\n  group_by(Sex) %>%\n  summarize(First = first(Dep.Var), \n            Last = last(Dep.Var), \n            Second = nth(Dep.Var, 2),\n            Second.Last = nth(Dep.Var, -2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  Sex   First    Last     Second   Second.Last\n  <fct> <fct>    <fct>    <fct>    <fct>      \n1 F     Realized Realized Deletion Realized   \n2 M     Realized Realized Deletion Deletion   \n```\n\n\n:::\n:::\n\nCompare the male values with those from the `head()` and `tail()` functions above.  The first (row 5) is `Realized`, the last (row 1198) is `Realized`. The second (row 6) is `Deletion`, and the second to last (row 1188) is also `Deletion`. \n\n### Count functions with `summarize()`\n\nWe've already looked at `n()` above, but there is also the `n_distinct()` function, which reports the number of distinct values. We can use this, for example, to find the number of speakers in each social category. To do this using base *R* filtering is a lot more complicated to code (so much so its not even worth doing). One example is shown below. It would need to be repeated for every combination of sex, education, and age group.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example using base R filtering, finding the number of unique speakers who are female, educated, and middle aged\n\nn_distinct(td$Speaker[td$Sex == \"F\" & td$Education == \"Educated\" & td$Age.Group == \"Middle\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\n# Much easier way to find number of unique speakers for every combination of Sex, Education, and Age. Group\n\ntd %>%\n  group_by(Sex, Education, Age.Group) %>%\n  summarize(Speaker.Count = n_distinct(Speaker)) %>%\n  print(n=Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n# Groups:   Sex, Education [6]\n   Sex   Education    Age.Group Speaker.Count\n   <fct> <fct>        <fct>             <int>\n 1 F     Educated     Old                   1\n 2 F     Educated     Middle               12\n 3 F     Educated     Young                 3\n 4 F     Not Educated Old                   6\n 5 F     Not Educated Middle                1\n 6 F     Student      Young                11\n 7 M     Educated     Middle                3\n 8 M     Educated     Young                 6\n 9 M     Not Educated Old                   5\n10 M     Not Educated Middle                7\n11 M     Not Educated Young                 3\n12 M     Student      Young                 8\n```\n\n\n:::\n:::\n\n\nYou'll notice that there are is no value for older educated males. This is because there are no speakers in the data from this group. \n\n### Logical functions\n\nThe two logical functions only work on data that is logical (i.e., is `TRUE` or `FALSE`). `any()` returns the answer to the question \"Are any values `TRUE`?\" and `all()` returns the answer to the question \"Are all values `TRUE`?\". There are no logical values in the `td` data set, so lets make some as an example. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a new column in which all values are FALSE\ntd$Logical.Test <- FALSE\n# Modify the new column so for any tokens from young female speakers are coded as TRUE instead of FALSE\ntd$Logical.Test[td$Sex == \"F\" & td$Age.Group == \"Young\"] <- TRUE\n\n# Get logical value (TRUE or FALSE) of whether any tokens and all tokens of Logical.Test are TRUE, by Sex\ntd %>%\n  group_by(Sex) %>%\n  summarize(Any.True = any(Logical.Test), \n            All.True = all(Logical.Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  Sex   Any.True All.True\n  <fct> <lgl>    <lgl>   \n1 F     TRUE     FALSE   \n2 M     FALSE    FALSE   \n```\n\n\n:::\n:::\n\n\nAbove we created a logical column in which only tokens from young females are set to `TRUE`.  The `any()` function returns `TRUE` for `F` but not for `M` because there is at least one `TRUE` value in the female data. Conversely, the `all()` function returns `FALSE` for `F` because not all of the female values are `TRUE`.\n\n## Proportions\n\nFinding out the proportion of a variant is just like finding out the number of tokens. Using the base *R* methods, you simply wrap the `table()` function in a `prop.table()` function. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var\nprop.table(table(td$Dep.Var))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nDeletion Realized \n   0.325    0.675 \n```\n\n\n:::\n:::\n\n\nUsually proportions are expressed as hundredths. To force *R* to express numbers in hundredths, you can use the `options()` function to set the number of significant digits displayed to two. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Display values rounded to nearest hundredth.  \noptions(digits = 2)\n\n# Proportion of each level of Dep.Var\nprop.table(table(td$Dep.Var))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nDeletion Realized \n    0.32     0.68 \n```\n\n\n:::\n:::\n\n\n\nIn the example above there is only one dimension: `Dep.Var`. The `prop.table()` outer function takes the `table()` inner function and divides the number of tokens in each cell by some total (e.g. denominator). The default denominator is the total number of tokens in the whole table. Because, in the example above, the total number of tokens in the one dimension table is the same as the total number of `Dep.Var` tokens, you don't need to specify anything further. In the example below, however, there are two dimensions: `Dep.Var` and `Age.Group`. If you do not specify which total to use as a denominator, the proportions expressed use the total number of tokens in the table as the denominator.[^4]  If you want to know the percentage of deletion tokens that come from `Young`, `Middle` and `Old` speakers, you set `margin = 1`, meaning that you want the total (e.g., denominator) to be the sum of the tokens for the first variable in the function, (e.g., rows total). If instead you want to know the percentage of `Young` tokens (or `Middle` tokens, or `Old` tokens) that are `Deletion`, and the percentage that are `Realized`, you set `margin = 2`, or rather set the denominator to the sum of the second factor group in the function (e.g., column total). This follows *R*'s global pattern of rows, columns, page 1, page 2, etc. You can verify this by adding up the proportions in each table below. In the first table all of the proportions add up to 1. In the second table, on the other hand, the proportions add up to 1 going across the rows. In the third table they add up to 1 going down the columns. \n\n[^4]: You'll notice that the values in this table are expressed in thousandths instead of hundredths. This is because the proportion for `Deletion` and `Old` tokens requires three decimal places to have two meaningful digits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var and Age.Group (all values sum to 1)\nprop.table(table(td$Dep.Var, td$Age.Group))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          \n             Old Middle Young\n  Deletion 0.056  0.105 0.163\n  Realized 0.113  0.198 0.365\n```\n\n\n:::\n\n```{.r .cell-code}\n# Proportion of each level of Age.Group for each level of Dep.Var (each row sums to 1)\nprop.table(table(td$Dep.Var, td$Age.Group), margin =1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          \n            Old Middle Young\n  Deletion 0.17   0.32  0.50\n  Realized 0.17   0.29  0.54\n```\n\n\n:::\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var for each level of Age.Group (each column sums to 1)\nprop.table(table(td$Dep.Var, td$Age.Group), margin = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          \n            Old Middle Young\n  Deletion 0.33   0.35  0.31\n  Realized 0.67   0.65  0.69\n```\n\n\n:::\n:::\n\n\n\nIn order to achieve the three-dimension cross-tabs you get from *Goldvarb*, with one dependent variable and two independent variables, you must set up the `prop.table(table())` function with your variables in the following order: *independent variable 1*, *independent variable 2*, *dependent variable*. You must also specify a particular `margin`, e.g., denominator. In a *Goldvarb*-style cross-tab each cell is the number of tokens for one level of the dependent variable (e.g., the application or non-application value) divided by the total number of tokens for that cell. In an *R* proportion table the total number of tokens per cell is the number of tokens for the value of the row and the column at the same time --- not the row total, or the column total. To specify that you want the denominator to be the cell total you set *margin = c(1,2)*, where the `c()` concatenating function specifies both row (1) and column (2). The result is a separate page for proportions of each level of `Dep.Var`. The proportions for the corresponding cells in each page add up to 1. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var for each level of Age.Group and Sex (all corresponding cells sum to 1)\nprop.table(table(td$Age.Group, td$Sex, td$Dep.Var), margin=c(1,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, ,  = Deletion\n\n        \n            F    M\n  Old    0.29 0.47\n  Middle 0.31 0.43\n  Young  0.27 0.34\n\n, ,  = Realized\n\n        \n            F    M\n  Old    0.71 0.53\n  Middle 0.69 0.57\n  Young  0.73 0.66\n```\n\n\n:::\n:::\n\n\n\nYou can keep adding factor groups to your proportion table, but you must do two things. You must keep the dependent variable, `Dep.Var`, as the rightmost variable in the function, and you must include all the other variables in the margin specification. For example, below you add  `Education` as the third variable, and add 3 to the margin specification. There will be a separate page for each combination of the levels of `Education` and `Dep.Var`. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var for each level of Age.Group, Sex and Education\nprop.table(table(td$Age.Group, td$Sex, td$Education, td$Dep.Var), margin=c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, ,  = Educated,  = Deletion\n\n        \n             F     M\n  Old    0.062      \n  Middle 0.308 0.348\n  Young  0.278 0.384\n\n, ,  = Not Educated,  = Deletion\n\n        \n             F     M\n  Old    0.347 0.471\n  Middle 0.294 0.474\n  Young        0.436\n\n, ,  = Student,  = Deletion\n\n        \n             F     M\n  Old               \n  Middle            \n  Young  0.261 0.282\n\n, ,  = Educated,  = Realized\n\n        \n             F     M\n  Old    0.938      \n  Middle 0.692 0.652\n  Young  0.722 0.616\n\n, ,  = Not Educated,  = Realized\n\n        \n             F     M\n  Old    0.653 0.529\n  Middle 0.706 0.526\n  Young        0.564\n\n, ,  = Student,  = Realized\n\n        \n             F     M\n  Old               \n  Middle            \n  Young  0.739 0.718\n```\n\n\n:::\n:::\n\n\n\nAgain, you can make these larger tables easier to read by flattening the pages using `ftable()`. Here the `NaN` means there is no data in the cell.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of each level of Dep.Var for each level of Age.Group, Sex and Education, presented as a flattened table. Here the `NaN' just means there is no data in the cell. \nlibrary(vcd)\nftable(prop.table(table(td$Age.Group, td$Sex, td$Education, td$Dep.Var), margin=c(1,2,3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                       Deletion Realized\n                                        \nOld    F Educated         0.062    0.938\n         Not Educated     0.347    0.653\n         Student            NaN      NaN\n       M Educated           NaN      NaN\n         Not Educated     0.471    0.529\n         Student            NaN      NaN\nMiddle F Educated         0.308    0.692\n         Not Educated     0.294    0.706\n         Student            NaN      NaN\n       M Educated         0.348    0.652\n         Not Educated     0.474    0.526\n         Student            NaN      NaN\nYoung  F Educated         0.278    0.722\n         Not Educated       NaN      NaN\n         Student          0.261    0.739\n       M Educated         0.384    0.616\n         Not Educated     0.436    0.564\n         Student          0.282    0.718\n```\n\n\n:::\n:::\n\n\nThere are a number of functions specifically designed to create cross-tables that are somewhat easier to use, but can be somewhat less flexible. Generally, they are most useful for one independent variable and one dependent variable. I tend to use the `CrossTable()` function from the `gmodels` package frequently. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load gmodels\nlibrary(gmodels)\n\n# Generate cross tab of Sex and Dep.Var in which the row proportions are displayed, but table proportions, column proportions, and contribution to chi-square are suppressed, with 0 decimal values displayed, and missing combinations included. \nCrossTable(td$Sex, td$Dep.Var, prop.r=TRUE, prop.c=FALSE, prop.t=FALSE, prop.chisq=FALSE, format=\"SPSS\", digits=0, missing.include=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   Cell Contents\n|-------------------------|\n|                   Count |\n|             Row Percent |\n|-------------------------|\n\nTotal Observations in Table:  1189 \n\n             | td$Dep.Var \n      td$Sex | Deletion  | Realized  | Row Total | \n-------------|-----------|-----------|-----------|\n           F |      188  |      471  |      659  | \n             |       29% |       71% |       55% | \n-------------|-----------|-----------|-----------|\n           M |      198  |      332  |      530  | \n             |       37% |       63% |       45% | \n-------------|-----------|-----------|-----------|\nColumn Total |      386  |      803  |     1189  | \n-------------|-----------|-----------|-----------|\n\n \n```\n\n\n:::\n:::\n\nFor the `CrossTable()` function you can set the denominator to row total with the option `prop.r=TRUE`. If instead you wanted to the proportion by column, you set `prop.c = TRUE`, and if you want the proportion across the entire table you can set `prop.t = TRUE`. You can actually set all of these to `TRUE` to get all three. There are other values that can be generated, including values for calculating chi-square (see the `CrossTable()` documentation [here](https://www.rdocumentation.org/packages/gmodels/versions/2.18.1.1/topics/CrossTable)). The above code includes the minimal number of options needed to generate the type of cross-table we generally want. \n\nTo produce proportions using the `tidy` method, we combine the `group_by()` and `summarize()` functions with the `mutate()` discussed in an [earlier section](https://lingmethodshub.github.io/content/R/lvc_r/040_lvcr.html).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate tibble of combination of Sex and Dep.Var with token counts and proportion of each level of Dep.Var by Sex \ntd %>%\n  group_by(Sex, Dep.Var) %>%\n  summarize(Count = n()) %>%\n  mutate(Prop = Count/sum(Count))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   Sex [2]\n  Sex   Dep.Var  Count  Prop\n  <fct> <fct>    <int> <dbl>\n1 F     Deletion   188 0.285\n2 F     Realized   471 0.715\n3 M     Deletion   198 0.374\n4 M     Realized   332 0.626\n```\n\n\n:::\n:::\n\n\nAfter grouping the data by `Sex` and `Dep.Var`, we create a new column `Count` with values equal to the number of tokens for the particular combination, then we create a new column using `mutate()` and a math equation to generate proportions. It is important here that your dependent variable `Dep.Var` is the last grouping variable. If we change the order, instead of generating the proportion of `Realized` and `Deletion` tokens, it will instead return the percentage of `Realized` tokens that are `M` and the percentage that are `F`, which is the incorrect denominator for our purposes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate tibble of combination of Dep.Var and Sex with token counts and proportion of each level of Sex by Dep.Var \ntd %>%\n  group_by(Dep.Var, Sex) %>%\n  summarize(Count = n()) %>%\n  mutate(Prop = Count/sum(Count))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   Dep.Var [2]\n  Dep.Var  Sex   Count  Prop\n  <fct>    <fct> <int> <dbl>\n1 Deletion F       188 0.487\n2 Deletion M       198 0.513\n3 Realized F       471 0.587\n4 Realized M       332 0.413\n```\n\n\n:::\n:::\n\n\nUnlike the `CrossTable()` function, we can include multiple independent variables. To include every combination (including those for which there are no tokens), we can add `.drop = FALSE` to the `group_by()` function. \n\n\n\n::: {.cell}\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate tibble of combination of Sex, Edcuation, Age.Group, and Dep.Var with all combinations included, with token counts and proportion of each level of Dep.Var by each combination of other variables\ntd %>%\n  group_by(Sex, Education, Age.Group, Dep.Var, .drop = FALSE) %>%\n  summarize(Count = n()) %>%\n  mutate(Prop = Count/sum(Count)) %>%\n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 36 × 6\n# Groups:   Sex, Education, Age.Group [18]\n   Sex   Education    Age.Group Dep.Var  Count     Prop\n   <fct> <fct>        <fct>     <fct>    <int>    <dbl>\n 1 F     Educated     Old       Deletion     2   0.0625\n 2 F     Educated     Old       Realized    30   0.938 \n 3 F     Educated     Middle    Deletion    68   0.308 \n 4 F     Educated     Middle    Realized   153   0.692 \n 5 F     Educated     Young     Deletion    20   0.278 \n 6 F     Educated     Young     Realized    52   0.722 \n 7 F     Not Educated Old       Deletion    41   0.347 \n 8 F     Not Educated Old       Realized    77   0.653 \n 9 F     Not Educated Middle    Deletion     5   0.294 \n10 F     Not Educated Middle    Realized    12   0.706 \n11 F     Not Educated Young     Deletion     0 NaN     \n12 F     Not Educated Young     Realized     0 NaN     \n13 F     Student      Old       Deletion     0 NaN     \n14 F     Student      Old       Realized     0 NaN     \n15 F     Student      Middle    Deletion     0 NaN     \n16 F     Student      Middle    Realized     0 NaN     \n17 F     Student      Young     Deletion    52   0.261 \n18 F     Student      Young     Realized   147   0.739 \n19 M     Educated     Old       Deletion     0 NaN     \n20 M     Educated     Old       Realized     0 NaN     \n21 M     Educated     Middle    Deletion    16   0.348 \n22 M     Educated     Middle    Realized    30   0.652 \n23 M     Educated     Young     Deletion    48   0.384 \n24 M     Educated     Young     Realized    77   0.616 \n25 M     Not Educated Old       Deletion    24   0.471 \n26 M     Not Educated Old       Realized    27   0.529 \n27 M     Not Educated Middle    Deletion    36   0.474 \n28 M     Not Educated Middle    Realized    40   0.526 \n29 M     Not Educated Young     Deletion    24   0.436 \n30 M     Not Educated Young     Realized    31   0.564 \n31 M     Student      Old       Deletion     0 NaN     \n32 M     Student      Old       Realized     0 NaN     \n33 M     Student      Middle    Deletion     0 NaN     \n34 M     Student      Middle    Realized     0 NaN     \n35 M     Student      Young     Deletion    50   0.282 \n36 M     Student      Young     Realized   127   0.718 \n```\n\n\n:::\n:::\n\nNotice that for the missing combinations the `count()` is 0, and the percentage is `NaN`, which stands for \"not a number\", the result of trying to divide 0 by something. `NaN` is similar to `NA`, but `NA` stands for \"no data\", and is used for empty cells. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign the tibble generated in the previous code to an object called results \nresults <- td %>%\n  group_by(Sex, Education, Age.Group, Dep.Var, .drop = FALSE) %>%\n  summarize(Count = n()) %>%\n  mutate(Prop = Count/sum(Count))\n\n# Recode all NaN in results to 0\nresults$Prop[is.nan(results$Prop)] <- 0 \n# Print results\nprint(results, n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 36 × 6\n# Groups:   Sex, Education, Age.Group [18]\n   Sex   Education    Age.Group Dep.Var  Count   Prop\n   <fct> <fct>        <fct>     <fct>    <int>  <dbl>\n 1 F     Educated     Old       Deletion     2 0.0625\n 2 F     Educated     Old       Realized    30 0.938 \n 3 F     Educated     Middle    Deletion    68 0.308 \n 4 F     Educated     Middle    Realized   153 0.692 \n 5 F     Educated     Young     Deletion    20 0.278 \n 6 F     Educated     Young     Realized    52 0.722 \n 7 F     Not Educated Old       Deletion    41 0.347 \n 8 F     Not Educated Old       Realized    77 0.653 \n 9 F     Not Educated Middle    Deletion     5 0.294 \n10 F     Not Educated Middle    Realized    12 0.706 \n11 F     Not Educated Young     Deletion     0 0     \n12 F     Not Educated Young     Realized     0 0     \n13 F     Student      Old       Deletion     0 0     \n14 F     Student      Old       Realized     0 0     \n15 F     Student      Middle    Deletion     0 0     \n16 F     Student      Middle    Realized     0 0     \n17 F     Student      Young     Deletion    52 0.261 \n18 F     Student      Young     Realized   147 0.739 \n19 M     Educated     Old       Deletion     0 0     \n20 M     Educated     Old       Realized     0 0     \n21 M     Educated     Middle    Deletion    16 0.348 \n22 M     Educated     Middle    Realized    30 0.652 \n23 M     Educated     Young     Deletion    48 0.384 \n24 M     Educated     Young     Realized    77 0.616 \n25 M     Not Educated Old       Deletion    24 0.471 \n26 M     Not Educated Old       Realized    27 0.529 \n27 M     Not Educated Middle    Deletion    36 0.474 \n28 M     Not Educated Middle    Realized    40 0.526 \n29 M     Not Educated Young     Deletion    24 0.436 \n30 M     Not Educated Young     Realized    31 0.564 \n31 M     Student      Old       Deletion     0 0     \n32 M     Student      Old       Realized     0 0     \n33 M     Student      Middle    Deletion     0 0     \n34 M     Student      Middle    Realized     0 0     \n35 M     Student      Young     Deletion    50 0.282 \n36 M     Student      Young     Realized   127 0.718 \n```\n\n\n:::\n:::\n\n\nThe easiest way to convert `NaN` (or `Na`) to 0 is to assign the above to a variable, then replace `NaN` with 0 using the function `is.nan()`. If there were `NA` values, you can do the same thing as above, but replace `is.nan()` with `is.na()`\n\n\nWhen we report proportions in sociolinguistics manuscripts, we often only report the proportion of one level of the dependent variable (called the application value). To only display one of the two levels of `Dep.Var` --- for instance, if we just want to show the rates of `Deletion`, which we might decide is our application value --- we can use the `subset()` function. \n\n \n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the results object, but subsetted to include only Deletion tokens\nresults <- td %>%\n  group_by(Sex, Education, Age.Group, Dep.Var, .drop = FALSE) %>%\n  summarize(Count = n()) %>%\n  mutate(Prop = Count/sum(Count)) %>%\n  subset(Dep.Var == \"Deletion\")\n\n# Recode NaN to 0\nresults$Prop[is.nan(results$Prop)] <- 0 \n# Print results\nprint(results, n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 6\n# Groups:   Sex, Education, Age.Group [18]\n   Sex   Education    Age.Group Dep.Var  Count   Prop\n   <fct> <fct>        <fct>     <fct>    <int>  <dbl>\n 1 F     Educated     Old       Deletion     2 0.0625\n 2 F     Educated     Middle    Deletion    68 0.308 \n 3 F     Educated     Young     Deletion    20 0.278 \n 4 F     Not Educated Old       Deletion    41 0.347 \n 5 F     Not Educated Middle    Deletion     5 0.294 \n 6 F     Not Educated Young     Deletion     0 0     \n 7 F     Student      Old       Deletion     0 0     \n 8 F     Student      Middle    Deletion     0 0     \n 9 F     Student      Young     Deletion    52 0.261 \n10 M     Educated     Old       Deletion     0 0     \n11 M     Educated     Middle    Deletion    16 0.348 \n12 M     Educated     Young     Deletion    48 0.384 \n13 M     Not Educated Old       Deletion    24 0.471 \n14 M     Not Educated Middle    Deletion    36 0.474 \n15 M     Not Educated Young     Deletion    24 0.436 \n16 M     Student      Old       Deletion     0 0     \n17 M     Student      Middle    Deletion     0 0     \n18 M     Student      Young     Deletion    50 0.282 \n```\n\n\n:::\n:::\n\n\nFinally, if we also want to add the total number of tokens per category (something we usually report alongside the application value) we can add another column using `mutate()`. Also, if we want the percentage instead of proportion, we can add `100 *` to the proportion equation (as percentage is proportion $\\times 100$)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate results object with percentage instead of proportion and a column with total tokens per combination. \nresults <- td %>%\n  group_by(Sex, Education, Age.Group, Dep.Var, .drop = FALSE) %>%\n  summarize(Count = n()) %>%\n  mutate(Percentage = 100*Count/sum(Count), \n         Total.N = sum(Count)) %>%\n  subset(Dep.Var == \"Deletion\")\n  \n# Recode NaN to 0\nresults$Percentage[is.nan(results$Percentage)] <- 0\n# Print results\nprint(results, n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 7\n# Groups:   Sex, Education, Age.Group [18]\n   Sex   Education    Age.Group Dep.Var  Count Percentage Total.N\n   <fct> <fct>        <fct>     <fct>    <int>      <dbl>   <int>\n 1 F     Educated     Old       Deletion     2       6.25      32\n 2 F     Educated     Middle    Deletion    68      30.8      221\n 3 F     Educated     Young     Deletion    20      27.8       72\n 4 F     Not Educated Old       Deletion    41      34.7      118\n 5 F     Not Educated Middle    Deletion     5      29.4       17\n 6 F     Not Educated Young     Deletion     0       0          0\n 7 F     Student      Old       Deletion     0       0          0\n 8 F     Student      Middle    Deletion     0       0          0\n 9 F     Student      Young     Deletion    52      26.1      199\n10 M     Educated     Old       Deletion     0       0          0\n11 M     Educated     Middle    Deletion    16      34.8       46\n12 M     Educated     Young     Deletion    48      38.4      125\n13 M     Not Educated Old       Deletion    24      47.1       51\n14 M     Not Educated Middle    Deletion    36      47.4       76\n15 M     Not Educated Young     Deletion    24      43.6       55\n16 M     Student      Old       Deletion     0       0          0\n17 M     Student      Middle    Deletion     0       0          0\n18 M     Student      Young     Deletion    50      28.2      177\n```\n\n\n:::\n:::\n\n\nThe above results show that there are 32 tokens from old, educated females, 2 of which (or 6.25%) are `Deletion`. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}