<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.296">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-06-14">

<title>LingMethodsHub - Predicting VOT-related landmarks in R with getVOT</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../content/R/animated_vowel_plots_tutorial/index.html" rel="prev">
<script src="../../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ES98D09K0F"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ES98D09K0F', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"express",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  });
});
</script> 
  
<style>html{ scroll-behavior: smooth; }</style>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false,
  "showHighlights": "never"
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="LingMethodsHub - Predicting VOT-related landmarks in R with getVOT">
<meta property="og:description" content="">
<meta property="og:image" content="https://lingmethodshub.github.io/content/R/getVOT-tutorial/index_files/figure-html/unnamed-chunk-2-1.png">
<meta property="og:site-name" content="LingMethodsHub">
<meta property="og:image:height" content="960">
<meta property="og:image:width" content="1344">
<meta name="twitter:title" content="LingMethodsHub - Predicting VOT-related landmarks in R with getVOT">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://lingmethodshub.github.io/content/R/getVOT-tutorial/index_files/figure-html/unnamed-chunk-2-1.png">
<meta name="twitter:image-height" content="960">
<meta name="twitter:image-width" content="1344">
<meta name="twitter:card" content="summary_large_image">
<meta name="citation_title" content="Predicting VOT-related landmarks in R with `getVOT`">
<meta name="citation_publication_date" content="2023-06-14">
<meta name="citation_cover_date" content="2023-06-14">
<meta name="citation_year" content="2023">
<meta name="citation_online_date" content="2023-06-14">
<meta name="citation_fulltext_html_url" content="https://lingmethodshub.github.io/content/R/getVOT-tutorial">
<meta name="citation_doi" content="10.5281/zenodo.8039257">
<meta name="citation_language" content="en">
<meta name="citation_journal_title" content="Linguistics Methods Hub">
<meta name="citation_series_title" content="Linguistics Methods Hub">
<meta name="citation_reference" content="citation_title=Transphonologization of onset voicing: revisiting Northern and Eastern Kmhmu’;,citation_author=James Kirby;,citation_author=Pittayawat Pittayaporn;,citation_author=Marc Brunelle;,citation_publication_date=2022-12-01;,citation_cover_date=2022-12-01;,citation_year=2022;,citation_issue=6;,citation_doi=10.1515/phon-2022-0029;,citation_volume=79;,citation_language=en;,citation_journal_title=Phonetica;">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">LingMethodsHub</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../../../index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/index.html" rel="" target="">
 <span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/contributing/index.html" rel="" target="">
 <span class="menu-text">Contributing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../people/index.html" rel="" target="">
 <span class="menu-text">People</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/LingMethodsHub/LingMethodsHub.github.io" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../content/R/index.html">R</a></li><li class="breadcrumb-item"><a href="../../../content/R/getVOT-tutorial/index.html">Predicting VOT-related landmarks in R with <code>getVOT</code></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../../index.html" class="sidebar-logo-link">
      <img src="../../../assets/logo.svg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorials</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/R/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">Doing LVC with R</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/010_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/020_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Your Data Into <em>R</em></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/030_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting to Know Your Data</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/040_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modifying Data</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/050_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Doing it all again, but <code>tidy</code></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/060_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Crosstabs: Counts, Proportions, and More</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/070_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Proportions for <code>ggplot2</code></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/080_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conditional Inference Trees</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/090_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Random Forests: The Basics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/110_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mixed-Efects Logistic Regression Analysis: Part 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/112_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mixed-Efects Logistic Regression Analysis: Part 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/114_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mixed-Efects Logistic Regression Analysis: Part 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/lvc_r/116_lvcr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mixed-Efects Logistic Regression Analysisː Part 4</span></a>
  </div>
</li>
          <li class="px-0"><hr class="sidebar-divider hi "></li>
      </ul>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/vowel-plots-tutorial/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vowel Plots with <code>ggplot2</code></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/tidy-norm/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">How to normalize your vowels using the tidyverse</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/animated_vowel_plots_tutorial/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Visualising Vowel Space Change with GAMMs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/R/getVOT-tutorial/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Predicting VOT-related landmarks in R with <code>getVOT</code></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/python/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/python/vowel-plotting-py/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vowel plotting in Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/python/speaker-diarization-for-linguistics/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Speaker Diarization for Linguistics</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Praat</span></span>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/tools/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tools</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/tools/mfa/mfa-tutorial/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Montreal Forced Aligner</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/tools/autovot/autovot-tutorial/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AutoVOT</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/cli/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Command Line Interfaces</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/cli/bash-shell-basics/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bash Shell Basics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/cli/keyboarding/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyboarding</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/windows/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Windows</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../content/windows/wsl/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Windows Subsystem for Linux</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../content/windows/wsl/00_installing_wsl.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Installation</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#predicting-vot-with-default-parameters" id="toc-predicting-vot-with-default-parameters" class="nav-link" data-scroll-target="#predicting-vot-with-default-parameters">Predicting VOT with default parameters</a>
  <ul class="collapse">
  <li><a href="#vot2newtg" id="toc-vot2newtg" class="nav-link" data-scroll-target="#vot2newtg"><code>VOT2newTG()</code></a></li>
  <li><a href="#addvot2tg" id="toc-addvot2tg" class="nav-link" data-scroll-target="#addvot2tg"><code>addVOT2TG()</code></a></li>
  </ul></li>
  <li><a href="#setting-parameters-with-training-data" id="toc-setting-parameters-with-training-data" class="nav-link" data-scroll-target="#setting-parameters-with-training-data">Setting parameters with training data</a></li>
  <li><a href="#how-does-it-work" id="toc-how-does-it-work" class="nav-link" data-scroll-target="#how-does-it-work">How does it work?</a>
  <ul class="collapse">
  <li><a href="#positive-vot" id="toc-positive-vot" class="nav-link" data-scroll-target="#positive-vot">Positive VOT</a></li>
  <li><a href="#negative-vot" id="toc-negative-vot" class="nav-link" data-scroll-target="#negative-vot">Negative VOT</a></li>
  </ul></li>
  <li><a href="#source-of-data" id="toc-source-of-data" class="nav-link" data-scroll-target="#source-of-data">Source of data</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Predicting VOT-related landmarks in R with <code>getVOT</code></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="http://rasmuspuggaard.wordpress.com">Rasmus Puggaard-Rode</a> </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Institute for Phonetics and Speech Processing, Ludwig Maximilian University of Munich
          </p>
      </div>
    </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 14, 2023</p>
    </div>
  </div>
  
    
    <div>
    <div class="quarto-title-meta-heading">Doi</div>
    <div class="quarto-title-meta-contents">
      <p class="doi">
        <a href="https://doi.org/10.5281/zenodo.8039257">10.5281/zenodo.8039257</a>
      </p>
    </div>
  </div>
  </div>
  

</header>

<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p><code>getVOT</code> is a developmental R package which predicts voice onset time (VOT) automatically. It can be installed from GitHub like so:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#install devtools if needed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages('devtools')</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(devtools)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">'rpuggaardrode/getVOT'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In most cases, VOT can be delimited visually from a waveform using a few clearly defined landmarks.</p>
<p>In voiceless stops, the first landmark is a sudden increase in amplitude following a period of silence, which corresponds to the stop release, and the second landmark is the onset of periodicity in the waveform corresponding to the onset of voicing. These two landmarks are shown here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#load sound file and TextGrid using rPraat</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>vl_snd <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vl/1.wav'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>vl_tg <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/1.TextGrid'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#rPraat loads sound files as a list, containing e.g. a vector of audio samples ($sig)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#which we plot as a regular line plot with the base plotting function.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">#the list also has information about time stamps ($t) which we plot on the x axis,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">#showing 50 ms to 250 ms.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">#TextGrids are loaded as a named list of tiers, this one has a tier called 'man'</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">#containing manually annotated VOT.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#each tier is itself a list including information about segmentations and start</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">#and end time of each interval.</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">#here we plot a blue vertical line for each interval of 'man'</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg<span class="sc">$</span>man<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="quarto-discovered-preview-image img-fluid" width="672"></p>
</div>
</div>
<p>In voiced stops, the process is essentially reversed: the first landmark is the onset of periodicity following a period of silence corresponding to the voicing onset, and the second landmark is a sudden increase in amplitude corresponding to the stop release. (Alternatively, the stop release is signaled by a <em>transient phase</em>, which is not easy to spot in the waveform but can usually be recognized by its spectral shape.) These two landmarks are shown below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>vd_snd <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vd/1.wav'</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>vd_tg <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vd/1.TextGrid'</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>man<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p><code>getVOT</code> attempts to predict these landmarks by loading sound files into R and using relatively simple algorithms to find those landmarks in the vector of samples corresponding to the waveform.</p>
<p>The goal is to partially make automatic, or at least aid in, the job of annotating VOT. There are other and more sophisticated algorithms available for predicting VOT, including <a href="https://github.com/mlml/autovot">AutoVOT</a> (see <a href="https://lingmethodshub.github.io/content/tools/autovot/autovot-tutorial/">Eleanor Chodroff’s tutorial</a>) and <a href="https://github.com/MLSpeech/Dr.VOT">Dr.VOT</a>. The job of <code>getVOT</code> is not to replace or even necessarily outperform these. AutoVOT only predicts positive VOT and scales best with a fair amount of training data; Dr.VOT predicts both positive and negative VOT, but can be a bit daunting to set up and difficult to manipulate; both can only be used on Unix-style operating systems. <code>getVOT</code> should be easy to set up and get started with, should be compatible with all operating systems, and should scale fairly well with little to no training data. This makes <code>getVOT</code> optimal for smaller data sets where providing suitable training data is difficult.</p>
<p>It should be noted though that this tutorial presents the very first publicly available version of <code>getVOT</code>, which is so far available only on GitHub. It is not perfect and the plan is to keep improving the code If you as a user run into any issues, you are encouraged to report an issue on the <a href="https://github.com/rpuggaardrode/getVOT/issues">GitHub page</a>.</p>
<p>In the next sections of this tutorial I give some examples of the most common use cases of the package. After that, for those interested, I summarize what is happening under the hood. I hope this may serve as general inspiration for those who want to solve acoustic problems in R programmatically. Perhaps inspiration will strike, and you’ll even come up with a more suitable method for finding VOT-related landmarks!</p>
</section>
<section id="predicting-vot-with-default-parameters" class="level2">
<h2 class="anchored" data-anchor-id="predicting-vot-with-default-parameters">Predicting VOT with default parameters</h2>
<p>The two most important <code>getVOT</code> functions in daily use are <code>VOT2newTG()</code> and <code>addVOT2TG()</code>. As the names suggest, <code>VOT2newTG()</code> will generate a new TextGrid where no annotations exist already. In this case, sound files should be short and consist of only a single word beginning with a stop. <code>addVOT2TG()</code> adds a new tier to an existing TextGrid with predicted VOT. In this case sound files can be any duration, but the existing TextGrid should indicate the rough location of stops.</p>
<section id="vot2newtg" class="level3">
<h3 class="anchored" data-anchor-id="vot2newtg"><code>VOT2newTG()</code></h3>
<p><code>VOT2newTG()</code> works like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(getVOT)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">VOT2newTG</span>(<span class="at">directory=</span><span class="st">'vl'</span>, <span class="at">sign=</span><span class="st">'positive'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1.TextGrid was not processed as this function only works with\n                   sound files with the .wav extension"
[1] "1.wav processed"</code></pre>
</div>
</div>
<p>The <code>directory</code> argument takes the name of a directory with sound files to be processed. The <code>sign</code> argument tells <code>getVOT</code> to use either positive or negative VOT. The default is actually both, i.e.&nbsp;<code>sign = c('positive', 'negative')</code>; in this case, a simple algorithm is used to try to predict whether VOT is positive or negative, but this algorithm is far from perfect so for now it is recommended to specify either <code>positive</code> or <code>negative</code>.</p>
<p>After running the above code, a new subdirectory of <code>vl</code> is created called <code>tg</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">list.dirs</span>(<span class="st">'vl'</span>, <span class="at">recursive=</span><span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "vl"    "vl/tg"</code></pre>
</div>
</div>
<p>The <code>tg</code> subdirectory contains TextGrid files for each processed sound file (which in this toy case is just 1):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">list.files</span>(<span class="st">'vl/tg'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1.TextGrid"</code></pre>
</div>
</div>
<p>Let’s load that TextGrid into R with <code>rPraat::tg.read()</code> and show the results:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>vl_tg_predVOT <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/tg/1.TextGrid'</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#first element of the t1 vector excluded because 0 is always the start time of an interval</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'blue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The results are a quite good, but a few ms off – we will return to this point in the next section.</p>
</section>
<section id="addvot2tg" class="level3">
<h3 class="anchored" data-anchor-id="addvot2tg"><code>addVOT2TG()</code></h3>
<p><code>addVOT2TG()</code> works like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addVOT2TG</span>(<span class="at">directory=</span><span class="st">'vd'</span>, <span class="at">sign=</span><span class="st">'negative'</span>, </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">tg_tier=</span><span class="st">'stops'</span>, <span class="at">seg_list=</span><span class="st">'b'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1 processed"</code></pre>
</div>
</div>
<p>The <code>directory</code> must be the name of a directory with sound file/TextGrid pairs, indicating roughly where to look for stops. In this case, we have just a single pair where the TextGrid has a tier named <code>stops</code> (the <code>tg_tier</code> argument), with one interval labeled <code>b</code> (the <code>seg_list</code> argument). This does not have to be a perfect match; the function will search for all intervals where the first character matches the strings in <code>seg_list</code>; this can be a single string like <code>'b'</code>, but could also be multiple strings like <code>c('b', 'd', 'g')</code>.</p>
<p>This was the position of the interval in the original TextGrid:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#write the TextGrid label at specified coordinates</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">y=</span><span class="sc">-</span><span class="fl">0.3</span>, <span class="at">x=</span><span class="fl">0.11</span>, <span class="at">labels=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>label, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">cex=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As before, the function creates a new subdirectory <code>vd/vot</code> with copies of the original TextGrids and a new tier with predicted VOT. The name of the new tier is set with the <code>addVOT2TG()</code> argument <code>new_tier_name</code>; default is <code>vot</code>. Let’s load in the new TextGrid and have a look at the results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>vd_tg_predVOT <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vd/vot/1.TextGrid'</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">y=</span><span class="sc">-</span><span class="fl">0.3</span>, <span class="at">x=</span><span class="fl">0.11</span>, <span class="at">labels=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>label, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">cex=</span><span class="dv">2</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'blue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="setting-parameters-with-training-data" class="level2">
<h2 class="anchored" data-anchor-id="setting-parameters-with-training-data">Setting parameters with training data</h2>
<p>Under the hood, the functions we’ve just seen will call the functions <code>positiveVOT()</code> and <code>negativeVOT()</code> which is where the actual VOT prediction is implemented. These functions take a bunch of obscure arguments which can be used to tweak the performance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(positiveVOT)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (sound, sr, closure_interval = 10, release_param = 15, 
    vo_method = "acf", vo_granularity = 1, vo_param = 0.85, f0_wl = 30, 
    f0_minacf = 0.5, burst_only = FALSE, f0_first = FALSE, plot = TRUE, 
    params_list = NULL) 
NULL</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(negativeVOT)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>function (sound, sr, vo_method = "acf", closure_interval = 10, 
    vo_granularity = 1.2, vo_param = 0.9, f0_wl = 50, f0_minacf = 0.5, 
    vo_only = FALSE, rel_method = "transient", plot = TRUE, params_list = NULL) 
NULL</code></pre>
</div>
</div>
<p>These parameters cannot be changed directly in <code>VOT2newTG()</code> and <code>addVOT2TG()</code>, but both functions take the arguments <code>pos_params_list</code> and <code>neg_params_list</code> which can be used to change the parameters. These <code>params_list</code>s should be named lists containing new settings for most of the <code>positiveVOT()</code> and <code>negativeVOT()</code> arguments; they can be written by hand, but since the arguments are not very easy to interpret, the idea is that they are written automatically using training data. The default parameters are chosen because they usually give quite good results, but mileage may vary a lot, so it is recommended to do this.</p>
<p>Training data should consist of sound file–TextGrid pairs. The sound files should be representative of the data that the user wants processed; if there are existing TextGrids (i.e., if the target function is <code>addVOT2TG()</code>), the training data should consist of short extracted sound snippets corresponding to the existing segmentation. The TextGrid should contain manually annotated VOT in the first tier. A small training set of say 5–10 pairs should give quite good results.</p>
<p>Automatic parameter setting is implemented in the functions <code>neg_setParams()</code> and <code>pos_setParams()</code>. I’ll demonstrate <code>pos_setParams()</code> below for a training set with three WAV–TextGrid pairs. The only obligatory argument in either case is <code>directory</code>, the location fo the training data. Note that these functions can take a long time to run – they try to predict VOT using a large range of parameters and return a list with the parameters that minimize the average difference between predicted VOT and manually annotated VOT.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>opt_params <span class="ot">&lt;-</span> <span class="fu">pos_setParams</span>(<span class="at">directory=</span><span class="st">'vl_training'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Testing burst detection parameter settings for 1.wav"
[1] "Testing burst detection parameter settings for 2.wav"
[1] "Testing burst detection parameter settings for 3.wav"
[1] "On average, the selected burst detection parameters after a first pass agree with the training data within a margin of 0.014 ms"
[1] "Finetuning burst detection parameter settings for 1.wav"
[1] "Finetuning burst detection parameter settings for 2.wav"
[1] "Finetuning burst detection parameter settings for 3.wav"
[1] "On average, the selected burst detection parameters after finetuning agree with the training data within a margin of 0.014 ms"
[1] "Testing voicing onset parameter settings for 1.wav"
[1] "Testing voicing onset parameter settings for 2.wav"
[1] "Testing voicing onset parameter settings for 3.wav"
[1] "On average, the selected voicing onset parameters after a first pass agree with the training data within a margin of 2.884 ms"
[1] "Finetuning voicing onset parameter settings for 1.wav"
[1] "Finetuning voicing onset parameter settings for 2.wav"
[1] "Finetuning voicing onset parameter settings for 3.wav"
[1] "On average, the selected voicing onset parameters after finetuning agree with the training data within a margin of 2.705 ms"</code></pre>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In addition to returning a list of optimized parameters, the <code>setParams()</code> functions will also print a bunch of messages in the terminal and return a plot. The messages will give an indication of how well the selected parameters fit the training data; in this case, the predicted bursts are extremely close to the annotated bursts, and predicted voicing onset is on average within roughly 3 ms of annotated voicing onset, which is within a reasonable margin of error. The returned plot will show the sound wave, with blue lines indicating manually annotated VOT, and red lines indicating predicted VOT. When the function is really successful, the red lines will not be visible at all.</p>
<p>These are the returned parameters:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>opt_params</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$closure_interval
[1] 8

$vo_granularity
[1] 1.4

$vo_param
[1] 0.92

$release_param
[1] 15

$f0_first
[1] FALSE

$vo_method
[1] "acf"

$f0_wl
NULL

$f0_minacf
NULL</code></pre>
</div>
</div>
<p>Note that they differ slightly from the default <code>positiveVOT()</code> parameters we saw above. In the next section, I’ll explain these parameters in more detail.</p>
<p>When we previously attempted to predict the VOT of an aspirated stop, the results were a tad off. Let’s try again with our <code>opt_params</code> and see if the results are better.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">VOT2newTG</span>(<span class="at">directory=</span><span class="st">'vl'</span>, <span class="at">sign=</span><span class="st">'positive'</span>, <span class="at">pos_params_list=</span>opt_params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1.TextGrid was not processed as this function only works with\n                   sound files with the .wav extension"
[1] "1.wav processed"</code></pre>
</div>
</div>
<p>We’ll load the resulting TextGrid into R, zoom into the sound a bit, and compare the previous results with default parameters (in red) with the new results with optimized parameters (in blue).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>vl_tg_predVOT_opt <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/tg/1.TextGrid'</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT_opt<span class="sc">$</span>vot<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>There is no noticeable difference in the predicted burst location, but the predicted voicing onset location is significantly improved.</p>
</section>
<section id="how-does-it-work" class="level2">
<h2 class="anchored" data-anchor-id="how-does-it-work">How does it work?</h2>
<p>In this section, I briefly describe what is going on under the hood when VOT is predicted. This should also help understand all the obscure arguments that make up the parameters lists.</p>
<section id="positive-vot" class="level3">
<h3 class="anchored" data-anchor-id="positive-vot">Positive VOT</h3>
<p>Positive VOT is predicted using the function <code>positiveVOT()</code>. The process will be exemplified using this sound file:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>vl_ex <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vl_training/1.wav'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">y=</span>vl_ex<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The first step to this process is to look for a stop closure. We do this by dividing up the first half of the sound file into intervals of duration <code>closure_interval</code> (default is <code>10</code> ms), and finding the one with the lowest mean amplitude. The intervals look like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract the sound samples, specify column 1 to get vector instead of array (there's only 1 column so doesn't matter)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>sound <span class="ot">&lt;-</span> vl_ex<span class="sc">$</span>sig[,<span class="dv">1</span>]</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">#extract sample rate</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>sr <span class="ot">&lt;-</span> vl_ex<span class="sc">$</span>fs</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">#set closure interval to default 10</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>closure_interval <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">#convert closure interval to seconds</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>ci <span class="ot">&lt;-</span> closure_interval<span class="sc">/</span><span class="dv">1000</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">#how many 10 ms intervals in the first half of the sound file? round up</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>sqlen <span class="ot">&lt;-</span> <span class="fu">ceiling</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span> <span class="sc">/</span> sr <span class="sc">/</span> ci)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of 10 ms intervals</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>sq_clo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>sr<span class="sc">*</span>ci, <span class="at">to=</span>sqlen<span class="sc">*</span>sr<span class="sc">*</span>ci, <span class="at">by=</span>sr<span class="sc">*</span>ci)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co">#add grey vertical lines each 10 ms</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'grey'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The midpoint of the interval with the lowest mean amplitude is assumed to be part of the stop closure. This point is marked in red below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">#make empty vector</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>mean_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">#set counter</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through intervals</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_clo) {</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with mean amplitude by interval ignoring sign</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  mean_amp[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">abs</span>(sound[(s<span class="sc">-</span>(sr<span class="sc">*</span>ci)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>s]))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">#increase counter</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="co">#closure is halfway through the interval with lowest mean amplitude</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>clo <span class="ot">&lt;-</span> (<span class="fu">which</span>(mean_amp<span class="sc">==</span><span class="fu">min</span>(mean_amp)) <span class="sc">-</span> <span class="fl">0.5</span>) <span class="sc">*</span> sr <span class="sc">*</span> ci</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'grey'</span>)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at predicted closure</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Next up, we predict that the stop release is the first brief interval after the closure where the amplitude is above some baseline. We split up the rest of the sound file after the predicted closure into intervals of 1 ms. We predict that the release is the first interval where the maximum amplitude is above a 1 / <code>release_param</code> (default is <code>15</code>) proportion of the highest amplitude in the sound. The highest amplitude is marked in blue here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at highest amplitude</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(sound)<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>And this is the first interval where the maximum amplitude is above 1/15 of that, marked in red:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set release_param argument at default 15</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>release_param <span class="ot">&lt;-</span> <span class="dv">15</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">#named object for number of samples per 1 ms, must be a whole number</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>step <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="dv">1</span> <span class="sc">*</span> (sr<span class="sc">/</span><span class="dv">1000</span>))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of 1ms intervals after predicted closure</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>sq_rel <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>clo, <span class="at">to=</span><span class="fu">length</span>(sound), <span class="at">by=</span>step)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">#empty vector, reset counter</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>max_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through 1ms intervals</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> <span class="fu">abs</span>(sq_rel)) {</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with most extreme amplitude per interval, ignoring sign</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>  max_amp[i] <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>step<span class="dv">-1</span>)]))</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co">#determine baseline amplitude for predicting stop release</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>spike_size <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(sound))<span class="sc">/</span>release_param</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of intervals above baseline</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>spike <span class="ot">&lt;-</span> <span class="fu">which</span>(max_amp <span class="sc">&gt;</span> spike_size)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of first interval above baseline</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">abs</span>((clo[<span class="dv">1</span>] <span class="sc">+</span> ((spike[<span class="dv">1</span>])<span class="sc">*</span>step))<span class="sc">-</span>step)</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(sound)<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for predicted release</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>rel<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Next up, by default we predict that the voicing onset is the first short interval where the mean autocorrelation of samples is above some baseline. We split the rest of the sound file after the predicted release into intervals with a duration of <code>vo_granularity</code> ms (default is <code>1</code>), and assume that the first voiced interval is the one where samples are on average autocorrelated more than <code>vo_param</code> % (default is <code>0.85</code>, i.e.&nbsp;85%) of the most autocorrelated interval in the sound file. The general idea is that voiced intervals are periodic, so correlation between adjacent samples should generally be quite high. On the other hand, intervals that occur during a voiceless stop release are noisy, so correlation between adjacent samples should be very low.</p>
<p>This may need a bit of unpacking. The most autocorrelated 1 ms interval is indicated with a blue line here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_granularity as default 1</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>vo_granularity <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">#convert vo_granularity to number of samples</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>vo_int <span class="ot">&lt;-</span> vo_granularity<span class="sc">*</span>step</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of intervals</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>sq_vo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>rel<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">5</span>), <span class="at">to=</span>rel<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">200</span>), <span class="at">by=</span>vo_int)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>mu_acf <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_vo) {</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#run acf on samples in interval, don't plot, ignore NAs</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  acf <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">acf</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>step<span class="dv">-1</span>)], <span class="at">plot=</span>F,</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>                    <span class="at">na.action=</span>stats<span class="sc">::</span>na.pass)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with mean autocorrelation across all lags</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  mu_acf[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(acf<span class="sc">$</span>acf)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for most autocorrelated interval</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_vo[<span class="fu">which.max</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>If we zoom into just that one ms interval, it looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of samples in most autocorrelated interval</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>max_acf <span class="ot">&lt;-</span> ((<span class="fu">which.max</span>(mu_acf))<span class="sc">*</span>step)<span class="sc">+</span>rel</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">#plot just those samples from the sound object</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sound[max_acf<span class="sc">:</span>(max_acf<span class="sc">+</span>vo_int)], <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Time (individual samples)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-24-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This clearly looks periodic. If we use the function <code>acf()</code> as below, we can see that adjacent samples are highly correlated, and autocorrelation with samples at lags up to six samples removed is generally quite high.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">#rerun acf on that interval, plot results this time</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">acf</span>(sound[max_acf<span class="sc">:</span>(max_acf<span class="sc">+</span>vo_int)], <span class="at">main=</span><span class="st">''</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This, on the other hand, is our least autocorrelated interval:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for least autocorrelated interval</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>rel<span class="sc">/</span>sr<span class="sc">+</span>sq_vo[<span class="fu">which.min</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-26-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>If we zoom in to just that one interval, we see a very jagged line.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>min_acf <span class="ot">&lt;-</span> ((<span class="fu">which.min</span>(mu_acf))<span class="sc">*</span>step)<span class="sc">+</span>rel</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sound[min_acf<span class="sc">:</span>(min_acf<span class="sc">+</span>vo_int)], <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Time (individual samples)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-27-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>And running <code>acf()</code> again, we see that autocorrelation is very low.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">acf</span>(sound[min_acf<span class="sc">:</span>(min_acf<span class="sc">+</span>vo_int)], <span class="at">main=</span><span class="st">''</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The first interval where the mean autocorrelation is above 85% of the most autocorrelated interval (i.e., the predicted voicing onset) is indicated with a red line here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_param as default 0.85</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>vo_param <span class="ot">&lt;-</span> <span class="fl">0.85</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of intervals where autocorrelation is above voicing onset baseline</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>hi_acf <span class="ot">&lt;-</span> <span class="fu">which</span>(mu_acf <span class="sc">&gt;</span> <span class="fu">max</span>(mu_acf, <span class="at">na.rm=</span>T)<span class="sc">*</span>vo_param)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">#voicing onset is predicted to be 1ms after the start of the second interval </span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">#above the baseline. helps to reduce the influence of random fluctuations, and</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">#usually the start of the first interval above the baseline precedes visible voicing.</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>vo <span class="ot">&lt;-</span> (rel <span class="sc">+</span> (hi_acf[<span class="dv">2</span>]<span class="sc">*</span>(step<span class="sc">*</span>vo_granularity)) <span class="sc">+</span> step)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_vo[<span class="fu">which.max</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-29-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Using the default parameters, this is exactly what goes on under the hood when the function <code>positiveVOT()</code> is called! One of the default parameters is <code>vo_method='acf'</code>, which implements the autocorrelation-based method for predicting voicing onset that we just saw. This is generally the most precise and by far the fastest method, but it is also a little fickle and will fail for lower quality audio or adverse recording conditions.</p>
<p>For this reason, another possibility is using the alternative <code>vo_method='f0'</code>. This method simply runs the pitch tracking algorithm implemented in the <code>pitchtrack()</code> function in the <code>phonTools</code> package, and predicts that voicing onset begins at the time of the first successful pitch measure after the stop release. The arguments <code>f0_wl</code> and <code>f0_minacf</code> are passed along to <code>phonTools::pitchtrack()</code> (as that function’s arguments <code>minacf</code> and <code>windowlength</code>). Note that the default <code>f0_wl</code> is 30 ms, which is quite a bit lower than the <code>phonTools::pitchtrack()</code> default of <code>50</code>; this seems to give better results when the purpose isn’t actually to measure pitch, but to find the first instance of voicing.</p>
<p>Finally, <code>positiveVOT()</code> also takes the argument <code>f0_first</code>, where the default is <code>FALSE</code>. If set to <code>TRUE</code>, the prediction process starts by finding the longest stretch of continuous pitch using <code>phonTools::pitchtrack()</code>, and subsequently looking for a stop release only within the 200 ms preceding the beginning of that stretch. As with <code>vo_method='f0'</code>, this is a relatively slow method, but can give better results when the recordings conditions and/or audio quality is suboptimal.</p>
</section>
<section id="negative-vot" class="level3">
<h3 class="anchored" data-anchor-id="negative-vot">Negative VOT</h3>
<p>Negative VOT is predicted using the function <code>negativeVOT()</code>. The process will be exemplified using the same voiced stop as we saw above. Just as when predicting positive VOT, the first step is to locate a stop closure by searching for the most silent interval of duration <code>closure_interval</code> (default is <code>10</code>) in the first half of the sound file. The implementation and result of this are shown here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract sound samples and overwrite sound object</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">#see same procedure for positiveVOT() above for commented code</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>sound <span class="ot">&lt;-</span> vd_snd<span class="sc">$</span>sig[,<span class="dv">1</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>closure_interval <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>ci <span class="ot">&lt;-</span> closure_interval<span class="sc">/</span><span class="dv">1000</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>sqlen <span class="ot">&lt;-</span> <span class="fu">ceiling</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span> <span class="sc">/</span> sr <span class="sc">/</span> ci)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>sq_clo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>sr<span class="sc">*</span>ci, <span class="at">to=</span>sqlen<span class="sc">*</span>sr<span class="sc">*</span>ci, <span class="at">by=</span>sr<span class="sc">*</span>ci)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>mean_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_clo) {</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  mean_amp[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">abs</span>(sound[(s<span class="sc">-</span>(sr<span class="sc">*</span>ci)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>s]))</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>clo <span class="ot">&lt;-</span> (<span class="fu">which</span>(mean_amp<span class="sc">==</span><span class="fu">min</span>(mean_amp)) <span class="sc">-</span> <span class="fl">0.5</span>) <span class="sc">*</span> sr <span class="sc">*</span> ci</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-30-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The default method for finding voicing onset is very similar for voiced and voiceless stops: the rest of the sound file after the predicted time of closure is divided into short intervals of duration <code>vo_granularity</code> (default is here <code>1.2</code> ms), and voicing onset is predicted to be the first interval where autocorrelation of samples within the interval is above some baseline – default is 90% of the most highly autocorrelated interval in the sound file (<code>vo_param = 0.9</code>). The implementation and result of this are shown here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_granularity as default 1.2</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>vo_granularity <span class="ot">&lt;-</span> <span class="fl">1.2</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of intervals</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>sq_vo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>clo, <span class="at">to=</span><span class="fu">length</span>(sound), <span class="at">by=</span>(step<span class="sc">*</span>vo_granularity))</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_param as default 0.9</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>vo_param <span class="ot">&lt;-</span> <span class="fl">0.9</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>mu_acf <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">#see same procedure for positiveVOT() above</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_vo) {</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  acf <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">acf</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>(step<span class="sc">*</span>vo_granularity)<span class="sc">-</span><span class="dv">1</span>)], <span class="at">plot=</span>F,</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>                    <span class="at">na.action=</span>stats<span class="sc">::</span>na.pass)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  mu_acf[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(acf<span class="sc">$</span>acf)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>hi_acf <span class="ot">&lt;-</span> <span class="fu">which</span>(mu_acf <span class="sc">&gt;</span> <span class="fu">max</span>(mu_acf, <span class="at">na.rm=</span>T)<span class="sc">*</span>vo_param)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>f0_start <span class="ot">&lt;-</span> (clo <span class="sc">+</span> (hi_acf[<span class="dv">2</span>]<span class="sc">*</span>(step<span class="sc">*</span>vo_granularity)) <span class="sc">+</span> step)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>f0_start<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-31-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As with <code>positiveVOT()</code>, <code>negativeVOT()</code> offers the alternative method for locating voicing onset <code>vo_method='f0'</code> with the default settings <code>f0_wl=50</code> and <code>f0_minacf=0.5</code> passed onto the <code>pitchtrack()</code> function of the <code>phonTools</code> package.</p>
<p>Finding the release of a prevoiced stop is trickier. The default method of <code>negativeVOT()</code> is to search for the so-called <em>transient phase</em> (<code>rel_method='transient'</code>). The transient phase of a stop is when the compressed air in the oral tract is discharged immediately at the time of the stop release. This results in a fairly even distribution of energy throughout the spectrum with a linear drop-off in energy at higher frequencies – in other words, a particularly <em>smooth</em> spectrum. These are tricky to find automatically as they’re very short.</p>
<p>The way this is implemented in <code>negativeVOT()</code> is by using the <code>spectralslice()</code> function in <code>phonTools</code> to generate FFT spectral slices of 1 ms sound intervals at each 10 samples after the predicted voicing onset. An FFT spectrum in R is just a vector of power measures by frequency bins; I estimate spectral smoothness by taking the standard deviation of the difference in power among adjacent frequency bins in the spectrum. A low number should indicate a smooth spectrum. I’ll unpack this with some code and plots.</p>
<p>This bit of code generates the spectra and calculates smoothness:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">#to save time, search only half the duration of the sound file after predicted voicing onset</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>srch <span class="ot">&lt;-</span> sound[f0_start<span class="sc">:</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span>)]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co">#set starting times each 10 samples for intervals to generate spectral slices from</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>steps <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">:</span>(<span class="fu">round</span>(<span class="fu">length</span>(srch)<span class="sc">/</span>step)<span class="sc">*</span><span class="dv">10</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>smoothness <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through starting times</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> steps) {</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">#determine 1 ms interval times</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  stp <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((i<span class="sc">*</span>step) <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#generate FFT spectral slice, don't plot</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">#spectralslice() returns a matrix, the second column contains power estimates, save those</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>  slice <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(stp<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>stp], <span class="at">show=</span>F)[,<span class="dv">2</span>]</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with spectral smoothness estimates</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  smoothness[i<span class="dv">-9</span>] <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">sd</span>(<span class="fu">diff</span>(slice))</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is an example of a rather jagged spectrum with a fairly high power difference between adjacent frequency bins. There’s voicing here, and especially the difference between the first few frequency bins is huge.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">#find most jagged spectrum (high "smoothness" estimate = low smoothness)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>max_smooth <span class="ot">&lt;-</span> <span class="fu">which</span>(smoothness <span class="sc">==</span> <span class="fu">max</span>(smoothness))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of most jagged spectrum</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>jagged <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((steps[max_smooth]<span class="sc">*</span>step)<span class="sc">/</span><span class="dv">10</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">#generate that jagged spectrum again for visualization purposes, don't use </span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co">#default plotting function because it doesn't return frequency in Hz scale</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>jagged_spec <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(jagged<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>jagged], <span class="at">show=</span>F)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co">#plot spectrum. first matrix column has frequency values, second has power estimates</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>jagged_spec[,<span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">y=</span>jagged_spec[,<span class="dv">2</span>], <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Power (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We can demonstrate this by plotting just the difference in power among adjacent frequency bins, instead of plotting the actual spectrum:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">#plot power difference between adjacent frequency bins. must exclude first bin on x axis,</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">#because diff(x) returns a vector of size x-1</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span><span class="fu">diff</span>(jagged_spec[,<span class="dv">2</span>]), <span class="at">x=</span>jagged_spec[,<span class="dv">1</span>][<span class="sc">-</span><span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Diff. betwen adjacent measures (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-34-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>By comparison, this is the smoothest spectrum in the file:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>min_smooth <span class="ot">&lt;-</span> <span class="fu">which</span>(smoothness <span class="sc">==</span> <span class="fu">min</span>(smoothness))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>smooth <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((steps[min_smooth]<span class="sc">*</span>step)<span class="sc">/</span><span class="dv">10</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>smooth_spec <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(smooth<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>smooth], <span class="at">show=</span>F)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>smooth_spec[,<span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">y=</span>smooth_spec[,<span class="dv">2</span>], <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Power (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-35-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This is immediately clear when plotting the difference between adjacent frequency bins using the same range for the Y-axis as we did for the less smooth spectrum above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span><span class="fu">diff</span>(smooth_spec[,<span class="dv">2</span>]), <span class="at">x=</span>smooth_spec[,<span class="dv">1</span>][<span class="sc">-</span><span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Diff. betwen adjacent measures (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">#set limits on y axis identically to the previous difference plot</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">range</span>(<span class="fu">diff</span>(jagged_spec)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-36-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>And this is the location in the sound file of that very smooth spectrum shown in red:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract location of predicted release in sound file, actually just slightly after smoothest spectrum</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>pred_rel <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> (((min_smooth<span class="sc">+</span><span class="dv">9</span>)<span class="sc">*</span>step) <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at location of predicted release</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>pred_rel<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-37-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As with using autocorrelation for locating voicing onset, using the transient phase to locate the release of a voiced stop is <em>fickle</em>; if the audio quality is good, I have found that it tends to give remarkably precise results. On the other hand, when it fails, it fails completely. It is also relatively slow, as it involves generating a lot of spectral slices. An alternative method is simply looking for increases in amplitude, as the amplitude of prevoicing is usually low. This method essentially looks for the beginning of the vowel rather than the stop release itself, and as such results are somewhat less precise. This method can be set with the parameter <code>rel_method='amplitude'</code>.</p>
<p>Here, we note the maximum amplitude in 1 ms intervals after the predicted voicing onset. This results in a time series that looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create a vector of 500x 1ms intervals starting at predicted voicing onset</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>sq_rel <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>f0_start, <span class="at">to=</span>f0_start<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">500</span>), <span class="at">by=</span>step)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>max_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_rel) {</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with highest amplitude of each interval</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>  max_amp[i] <span class="ot">&lt;-</span> <span class="fu">max</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>(step)<span class="sc">-</span><span class="dv">1</span>)])</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="co">#remove any NAs from max_amp vector if 500x 1ms intervals are not available </span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="co">#(not really necessary here)</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">length</span>(<span class="fu">which</span>(<span class="fu">is.na</span>(max_amp))) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>  max_amp <span class="ot">&lt;-</span> max_amp[<span class="sc">-</span><span class="fu">which</span>(<span class="fu">is.na</span>(max_amp))]</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="co">#plot maximum amplitude per interval as time series</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(max_amp, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-38-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This is much too jagged to be of any use, but we can get a clearer picture by smoothing it out. We do this using a discrete cosine transformation, as implemented in the <code>dct()</code> function of <code>emuR</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">#smooth above time series using DCT based on 25 coefficients, don't plot, store fitted object</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>dct_fit <span class="ot">&lt;-</span> emuR<span class="sc">::</span><span class="fu">dct</span>(max_amp, <span class="at">m=</span><span class="dv">25</span>, <span class="at">fit=</span>T)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">#plot smoothed time series</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dct_fit, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window (smoothed)'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-39-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The predicted stop release is 5 ms before we see the highest velocity in this time series. The highest velocity is indicated with a blue line here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">#save vector with difference between each adjacent max amplitude from smoothed time series</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>diff_amp <span class="ot">&lt;-</span> <span class="fu">diff</span>(dct_fit)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">#replot smoothed time series</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dct_fit, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window (smoothed)'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line with location of highest difference</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(diff_amp), <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-40-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This predicts this stop release location:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">#locate predicted stop release, 5ms prior to highest amplitude increase</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>pred_rel_amp <span class="ot">&lt;-</span> sq_rel[<span class="fu">which.max</span>(diff_amp)] <span class="sc">-</span> (step <span class="sc">*</span> <span class="dv">5</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for predicted stop release</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>pred_rel_amp<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-41-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>That covers all the parameters of <code>negativeVOT()</code>.</p>
</section>
</section>
<section id="source-of-data" class="level2">
<h2 class="anchored" data-anchor-id="source-of-data">Source of data</h2>
<p>The sound files used for demonstrating the <code>getVOT</code> functions throughout the tutorial are in Kmhmu’, taken from <a href="https://osf.io/wv6qz">this OSF repository</a>. The data were collected to study transphonologization of onset voicing. See <span class="citation" data-cites="kirby2022">Kirby &amp; Pittayaporn &amp; Brunelle (<a href="#ref-kirby2022" role="doc-biblioref">2022</a>)</span>.</p>


<!-- -->


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-line-spacing="2" role="list">
<div id="ref-kirby2022" class="csl-entry" role="listitem">
Kirby, James &amp; Pittayaporn, Pittayawat &amp; Brunelle, Marc. 2022. <a href="https://doi.org/10.1515/phon-2022-0029">Transphonologization of onset voicing: revisiting Northern and Eastern Kmhmu<span>’</span></a>. <em>Phonetica</em>. 79(6). 591–629.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div>CC-BY-SA 4.0</div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{puggaard-rode2023,
  author = {Puggaard-Rode, Rasmus},
  title = {Predicting {VOT-related} Landmarks in {R} with {`getVOT`}},
  series = {Linguistics Methods Hub},
  date = {2023-06-14},
  url = {https://lingmethodshub.github.io/content/R/getVOT-tutorial},
  doi = {10.5281/zenodo.8039257},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-puggaard-rode2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Puggaard-Rode, Rasmus. 2023, June 14. Predicting VOT-related landmarks
in R with `getVOT`. <em>Linguistics Methods Hub</em>. (<a href="https://lingmethodshub.github.io/content/R/getVOT-tutorial">https://lingmethodshub.github.io/content/R/getVOT-tutorial</a>).
doi: <a href="https://doi.org/10.5281/zenodo.8039257">10.5281/zenodo.8039257</a>
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../content/R/animated_vowel_plots_tutorial/index.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Visualising Vowel Space Change with GAMMs</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb50" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Predicting VOT-related landmarks in R with `getVOT`"</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: </span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co">      given: "Rasmus"</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co">      family: "Puggaard-Rode"</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: "http://rasmuspuggaard.wordpress.com"</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: "Institute for Phonetics and Speech Processing, Ludwig Maximilian University of Munich"</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2023-06-14</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="an">license:</span><span class="co"> "CC-BY-SA 4.0"</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a><span class="co">  html: default</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a><span class="co">  pdf: default</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a><span class="an">editor:</span><span class="co"> visual</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a><span class="an">knitr:</span><span class="co"> </span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a><span class="co">  opts_chunk: </span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a><span class="co">    message: false</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a><span class="in">`getVOT`</span> is a developmental R package which predicts voice onset time (VOT) automatically. It can be installed from GitHub like so:</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a><span class="co">#install devtools if needed</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages('devtools')</span></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(devtools)</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">'rpuggaardrode/getVOT'</span>)</span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>In most cases, VOT can be delimited visually from a waveform using a few clearly defined landmarks.</span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>In voiceless stops, the first landmark is a sudden increase in amplitude following a period of silence, which corresponds to the stop release, and the second landmark is the onset of periodicity in the waveform corresponding to the onset of voicing. These two landmarks are shown here:</span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a><span class="co">#load sound file and TextGrid using rPraat</span></span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>vl_snd <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vl/1.wav'</span>)</span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>vl_tg <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/1.TextGrid'</span>)</span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a><span class="co">#rPraat loads sound files as a list, containing e.g. a vector of audio samples ($sig)</span></span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a><span class="co">#which we plot as a regular line plot with the base plotting function.</span></span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a><span class="co">#the list also has information about time stamps ($t) which we plot on the x axis,</span></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a><span class="co">#showing 50 ms to 250 ms.</span></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a><span class="co">#TextGrids are loaded as a named list of tiers, this one has a tier called 'man'</span></span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a><span class="co">#containing manually annotated VOT.</span></span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a><span class="co">#each tier is itself a list including information about segmentations and start</span></span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a><span class="co">#and end time of each interval.</span></span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a><span class="co">#here we plot a blue vertical line for each interval of 'man'</span></span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg<span class="sc">$</span>man<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a>In voiced stops, the process is essentially reversed: the first landmark is the onset of periodicity following a period of silence corresponding to the voicing onset, and the second landmark is a sudden increase in amplitude corresponding to the stop release. (Alternatively, the stop release is signaled by a *transient phase*, which is not easy to spot in the waveform but can usually be recognized by its spectral shape.) These two landmarks are shown below.</span>
<span id="cb50-63"><a href="#cb50-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-66"><a href="#cb50-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-67"><a href="#cb50-67" aria-hidden="true" tabindex="-1"></a>vd_snd <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vd/1.wav'</span>)</span>
<span id="cb50-68"><a href="#cb50-68" aria-hidden="true" tabindex="-1"></a>vd_tg <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vd/1.TextGrid'</span>)</span>
<span id="cb50-69"><a href="#cb50-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-70"><a href="#cb50-70" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb50-71"><a href="#cb50-71" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb50-72"><a href="#cb50-72" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>man<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span>
<span id="cb50-73"><a href="#cb50-73" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-74"><a href="#cb50-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-75"><a href="#cb50-75" aria-hidden="true" tabindex="-1"></a><span class="in">`getVOT`</span> attempts to predict these landmarks by loading sound files into R and using relatively simple algorithms to find those landmarks in the vector of samples corresponding to the waveform.</span>
<span id="cb50-76"><a href="#cb50-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-77"><a href="#cb50-77" aria-hidden="true" tabindex="-1"></a>The goal is to partially make automatic, or at least aid in, the job of annotating VOT. There are other and more sophisticated algorithms available for predicting VOT, including <span class="co">[</span><span class="ot">AutoVOT</span><span class="co">](https://github.com/mlml/autovot)</span> (see <span class="co">[</span><span class="ot">Eleanor Chodroff's tutorial</span><span class="co">](https://lingmethodshub.github.io/content/tools/autovot/autovot-tutorial/)</span>) and <span class="co">[</span><span class="ot">Dr.VOT</span><span class="co">](https://github.com/MLSpeech/Dr.VOT)</span>. The job of <span class="in">`getVOT`</span> is not to replace or even necessarily outperform these. AutoVOT only predicts positive VOT and scales best with a fair amount of training data; Dr.VOT predicts both positive and negative VOT, but can be a bit daunting to set up and difficult to manipulate; both can only be used on Unix-style operating systems. <span class="in">`getVOT`</span> should be easy to set up and get started with, should be compatible with all operating systems, and should scale fairly well with little to no training data. This makes <span class="in">`getVOT`</span> optimal for smaller data sets where providing suitable training data is difficult.</span>
<span id="cb50-78"><a href="#cb50-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-79"><a href="#cb50-79" aria-hidden="true" tabindex="-1"></a>It should be noted though that this tutorial presents the very first publicly available version of <span class="in">`getVOT`</span>, which is so far available only on GitHub. It is not perfect and the plan is to keep improving the code If you as a user run into any issues, you are encouraged to report an issue on the <span class="co">[</span><span class="ot">GitHub page</span><span class="co">](https://github.com/rpuggaardrode/getVOT/issues)</span>.</span>
<span id="cb50-80"><a href="#cb50-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-81"><a href="#cb50-81" aria-hidden="true" tabindex="-1"></a>In the next sections of this tutorial I give some examples of the most common use cases of the package. After that, for those interested, I summarize what is happening under the hood. I hope this may serve as general inspiration for those who want to solve acoustic problems in R programmatically. Perhaps inspiration will strike, and you'll even come up with a more suitable method for finding VOT-related landmarks!</span>
<span id="cb50-82"><a href="#cb50-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-83"><a href="#cb50-83" aria-hidden="true" tabindex="-1"></a><span class="fu">## Predicting VOT with default parameters</span></span>
<span id="cb50-84"><a href="#cb50-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-85"><a href="#cb50-85" aria-hidden="true" tabindex="-1"></a>The two most important <span class="in">`getVOT`</span> functions in daily use are <span class="in">`VOT2newTG()`</span> and <span class="in">`addVOT2TG()`</span>. As the names suggest, <span class="in">`VOT2newTG()`</span> will generate a new TextGrid where no annotations exist already. In this case, sound files should be short and consist of only a single word beginning with a stop. <span class="in">`addVOT2TG()`</span> adds a new tier to an existing TextGrid with predicted VOT. In this case sound files can be any duration, but the existing TextGrid should indicate the rough location of stops.</span>
<span id="cb50-86"><a href="#cb50-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-87"><a href="#cb50-87" aria-hidden="true" tabindex="-1"></a><span class="fu">### `VOT2newTG()`</span></span>
<span id="cb50-88"><a href="#cb50-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-89"><a href="#cb50-89" aria-hidden="true" tabindex="-1"></a><span class="in">`VOT2newTG()`</span> works like this:</span>
<span id="cb50-90"><a href="#cb50-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-93"><a href="#cb50-93" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-94"><a href="#cb50-94" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(getVOT)</span>
<span id="cb50-95"><a href="#cb50-95" aria-hidden="true" tabindex="-1"></a><span class="fu">VOT2newTG</span>(<span class="at">directory=</span><span class="st">'vl'</span>, <span class="at">sign=</span><span class="st">'positive'</span>)</span>
<span id="cb50-96"><a href="#cb50-96" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-97"><a href="#cb50-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-98"><a href="#cb50-98" aria-hidden="true" tabindex="-1"></a>The <span class="in">`directory`</span> argument takes the name of a directory with sound files to be processed. The <span class="in">`sign`</span> argument tells <span class="in">`getVOT`</span> to use either positive or negative VOT. The default is actually both, i.e. <span class="in">`sign = c('positive', 'negative')`</span>; in this case, a simple algorithm is used to try to predict whether VOT is positive or negative, but this algorithm is far from perfect so for now it is recommended to specify either <span class="in">`positive`</span> or <span class="in">`negative`</span>.</span>
<span id="cb50-99"><a href="#cb50-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-100"><a href="#cb50-100" aria-hidden="true" tabindex="-1"></a>After running the above code, a new subdirectory of <span class="in">`vl`</span> is created called <span class="in">`tg`</span>:</span>
<span id="cb50-101"><a href="#cb50-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-104"><a href="#cb50-104" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-105"><a href="#cb50-105" aria-hidden="true" tabindex="-1"></a><span class="fu">list.dirs</span>(<span class="st">'vl'</span>, <span class="at">recursive=</span><span class="cn">TRUE</span>)</span>
<span id="cb50-106"><a href="#cb50-106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-107"><a href="#cb50-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-108"><a href="#cb50-108" aria-hidden="true" tabindex="-1"></a>The <span class="in">`tg`</span> subdirectory contains TextGrid files for each processed sound file (which in this toy case is just 1):</span>
<span id="cb50-109"><a href="#cb50-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-112"><a href="#cb50-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-113"><a href="#cb50-113" aria-hidden="true" tabindex="-1"></a><span class="fu">list.files</span>(<span class="st">'vl/tg'</span>)</span>
<span id="cb50-114"><a href="#cb50-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-115"><a href="#cb50-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-116"><a href="#cb50-116" aria-hidden="true" tabindex="-1"></a>Let's load that TextGrid into R with <span class="in">`rPraat::tg.read()`</span> and show the results:</span>
<span id="cb50-117"><a href="#cb50-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-120"><a href="#cb50-120" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-121"><a href="#cb50-121" aria-hidden="true" tabindex="-1"></a>vl_tg_predVOT <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/tg/1.TextGrid'</span>)</span>
<span id="cb50-122"><a href="#cb50-122" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb50-123"><a href="#cb50-123" aria-hidden="true" tabindex="-1"></a><span class="co">#first element of the t1 vector excluded because 0 is always the start time of an interval</span></span>
<span id="cb50-124"><a href="#cb50-124" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'blue'</span>)</span>
<span id="cb50-125"><a href="#cb50-125" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-126"><a href="#cb50-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-127"><a href="#cb50-127" aria-hidden="true" tabindex="-1"></a>The results are a quite good, but a few ms off -- we will return to this point in the next section.</span>
<span id="cb50-128"><a href="#cb50-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-129"><a href="#cb50-129" aria-hidden="true" tabindex="-1"></a><span class="fu">### `addVOT2TG()`</span></span>
<span id="cb50-130"><a href="#cb50-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-131"><a href="#cb50-131" aria-hidden="true" tabindex="-1"></a><span class="in">`addVOT2TG()`</span> works like this:</span>
<span id="cb50-132"><a href="#cb50-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-135"><a href="#cb50-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-136"><a href="#cb50-136" aria-hidden="true" tabindex="-1"></a><span class="fu">addVOT2TG</span>(<span class="at">directory=</span><span class="st">'vd'</span>, <span class="at">sign=</span><span class="st">'negative'</span>, </span>
<span id="cb50-137"><a href="#cb50-137" aria-hidden="true" tabindex="-1"></a>          <span class="at">tg_tier=</span><span class="st">'stops'</span>, <span class="at">seg_list=</span><span class="st">'b'</span>)</span>
<span id="cb50-138"><a href="#cb50-138" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-139"><a href="#cb50-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-140"><a href="#cb50-140" aria-hidden="true" tabindex="-1"></a>The <span class="in">`directory`</span> must be the name of a directory with sound file/TextGrid pairs, indicating roughly where to look for stops. In this case, we have just a single pair where the TextGrid has a tier named <span class="in">`stops`</span> (the <span class="in">`tg_tier`</span> argument), with one interval labeled <span class="in">`b`</span> (the <span class="in">`seg_list`</span> argument). This does not have to be a perfect match; the function will search for all intervals where the first character matches the strings in <span class="in">`seg_list`</span>; this can be a single string like <span class="in">`'b'`</span>, but could also be multiple strings like <span class="in">`c('b', 'd', 'g')`</span>.</span>
<span id="cb50-141"><a href="#cb50-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-142"><a href="#cb50-142" aria-hidden="true" tabindex="-1"></a>This was the position of the interval in the original TextGrid:</span>
<span id="cb50-143"><a href="#cb50-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-146"><a href="#cb50-146" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-147"><a href="#cb50-147" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb50-148"><a href="#cb50-148" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb50-149"><a href="#cb50-149" aria-hidden="true" tabindex="-1"></a><span class="co">#write the TextGrid label at specified coordinates</span></span>
<span id="cb50-150"><a href="#cb50-150" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">y=</span><span class="sc">-</span><span class="fl">0.3</span>, <span class="at">x=</span><span class="fl">0.11</span>, <span class="at">labels=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>label, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">cex=</span><span class="dv">2</span>)</span>
<span id="cb50-151"><a href="#cb50-151" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-152"><a href="#cb50-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-153"><a href="#cb50-153" aria-hidden="true" tabindex="-1"></a>As before, the function creates a new subdirectory <span class="in">`vd/vot`</span> with copies of the original TextGrids and a new tier with predicted VOT. The name of the new tier is set with the <span class="in">`addVOT2TG()`</span> argument <span class="in">`new_tier_name`</span>; default is <span class="in">`vot`</span>. Let's load in the new TextGrid and have a look at the results.</span>
<span id="cb50-154"><a href="#cb50-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-157"><a href="#cb50-157" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-158"><a href="#cb50-158" aria-hidden="true" tabindex="-1"></a>vd_tg_predVOT <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vd/vot/1.TextGrid'</span>)</span>
<span id="cb50-159"><a href="#cb50-159" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">y=</span>vd_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb50-160"><a href="#cb50-160" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb50-161"><a href="#cb50-161" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">y=</span><span class="sc">-</span><span class="fl">0.3</span>, <span class="at">x=</span><span class="fl">0.11</span>, <span class="at">labels=</span>vd_tg<span class="sc">$</span>stops<span class="sc">$</span>label, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">cex=</span><span class="dv">2</span>)</span>
<span id="cb50-162"><a href="#cb50-162" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vd_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1[<span class="sc">-</span><span class="dv">1</span>], <span class="at">col=</span><span class="st">'blue'</span>)</span>
<span id="cb50-163"><a href="#cb50-163" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-164"><a href="#cb50-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-167"><a href="#cb50-167" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-168"><a href="#cb50-168" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb50-169"><a href="#cb50-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-170"><a href="#cb50-170" aria-hidden="true" tabindex="-1"></a><span class="co">#remove programmatically created folders</span></span>
<span id="cb50-171"><a href="#cb50-171" aria-hidden="true" tabindex="-1"></a><span class="fu">unlink</span>(<span class="st">'vd/vot'</span>, <span class="at">recursive=</span><span class="cn">TRUE</span>)</span>
<span id="cb50-172"><a href="#cb50-172" aria-hidden="true" tabindex="-1"></a><span class="fu">unlink</span>(<span class="st">'vl/tg'</span>, <span class="at">recursive=</span><span class="cn">TRUE</span>)</span>
<span id="cb50-173"><a href="#cb50-173" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-174"><a href="#cb50-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-175"><a href="#cb50-175" aria-hidden="true" tabindex="-1"></a><span class="fu">## Setting parameters with training data</span></span>
<span id="cb50-176"><a href="#cb50-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-177"><a href="#cb50-177" aria-hidden="true" tabindex="-1"></a>Under the hood, the functions we've just seen will call the functions <span class="in">`positiveVOT()`</span> and <span class="in">`negativeVOT()`</span> which is where the actual VOT prediction is implemented. These functions take a bunch of obscure arguments which can be used to tweak the performance.</span>
<span id="cb50-178"><a href="#cb50-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-181"><a href="#cb50-181" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-182"><a href="#cb50-182" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(positiveVOT)</span>
<span id="cb50-183"><a href="#cb50-183" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(negativeVOT)</span>
<span id="cb50-184"><a href="#cb50-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-185"><a href="#cb50-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-186"><a href="#cb50-186" aria-hidden="true" tabindex="-1"></a>These parameters cannot be changed directly in <span class="in">`VOT2newTG()`</span> and <span class="in">`addVOT2TG()`</span>, but both functions take the arguments <span class="in">`pos_params_list`</span> and <span class="in">`neg_params_list`</span> which can be used to change the parameters. These <span class="in">`params_list`</span>s should be named lists containing new settings for most of the <span class="in">`positiveVOT()`</span> and <span class="in">`negativeVOT()`</span> arguments; they can be written by hand, but since the arguments are not very easy to interpret, the idea is that they are written automatically using training data. The default parameters are chosen because they usually give quite good results, but mileage may vary a lot, so it is recommended to do this.</span>
<span id="cb50-187"><a href="#cb50-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-188"><a href="#cb50-188" aria-hidden="true" tabindex="-1"></a>Training data should consist of sound file--TextGrid pairs. The sound files should be representative of the data that the user wants processed; if there are existing TextGrids (i.e., if the target function is <span class="in">`addVOT2TG()`</span>), the training data should consist of short extracted sound snippets corresponding to the existing segmentation. The TextGrid should contain manually annotated VOT in the first tier. A small training set of say 5--10 pairs should give quite good results.</span>
<span id="cb50-189"><a href="#cb50-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-190"><a href="#cb50-190" aria-hidden="true" tabindex="-1"></a>Automatic parameter setting is implemented in the functions <span class="in">`neg_setParams()`</span> and <span class="in">`pos_setParams()`</span>. I'll demonstrate <span class="in">`pos_setParams()`</span> below for a training set with three WAV--TextGrid pairs. The only obligatory argument in either case is <span class="in">`directory`</span>, the location fo the training data. Note that these functions can take a long time to run -- they try to predict VOT using a large range of parameters and return a list with the parameters that minimize the average difference between predicted VOT and manually annotated VOT.</span>
<span id="cb50-191"><a href="#cb50-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-194"><a href="#cb50-194" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-195"><a href="#cb50-195" aria-hidden="true" tabindex="-1"></a>opt_params <span class="ot">&lt;-</span> <span class="fu">pos_setParams</span>(<span class="at">directory=</span><span class="st">'vl_training'</span>)</span>
<span id="cb50-196"><a href="#cb50-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-197"><a href="#cb50-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-198"><a href="#cb50-198" aria-hidden="true" tabindex="-1"></a>In addition to returning a list of optimized parameters, the <span class="in">`setParams()`</span> functions will also print a bunch of messages in the terminal and return a plot. The messages will give an indication of how well the selected parameters fit the training data; in this case, the predicted bursts are extremely close to the annotated bursts, and predicted voicing onset is on average within roughly 3 ms of annotated voicing onset, which is within a reasonable margin of error. The returned plot will show the sound wave, with blue lines indicating manually annotated VOT, and red lines indicating predicted VOT. When the function is really successful, the red lines will not be visible at all.</span>
<span id="cb50-199"><a href="#cb50-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-200"><a href="#cb50-200" aria-hidden="true" tabindex="-1"></a>These are the returned parameters:</span>
<span id="cb50-201"><a href="#cb50-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-204"><a href="#cb50-204" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-205"><a href="#cb50-205" aria-hidden="true" tabindex="-1"></a>opt_params</span>
<span id="cb50-206"><a href="#cb50-206" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-207"><a href="#cb50-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-208"><a href="#cb50-208" aria-hidden="true" tabindex="-1"></a>Note that they differ slightly from the default <span class="in">`positiveVOT()`</span> parameters we saw above. In the next section, I'll explain these parameters in more detail.</span>
<span id="cb50-209"><a href="#cb50-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-210"><a href="#cb50-210" aria-hidden="true" tabindex="-1"></a>When we previously attempted to predict the VOT of an aspirated stop, the results were a tad off. Let's try again with our <span class="in">`opt_params`</span> and see if the results are better.</span>
<span id="cb50-211"><a href="#cb50-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-214"><a href="#cb50-214" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-215"><a href="#cb50-215" aria-hidden="true" tabindex="-1"></a><span class="fu">VOT2newTG</span>(<span class="at">directory=</span><span class="st">'vl'</span>, <span class="at">sign=</span><span class="st">'positive'</span>, <span class="at">pos_params_list=</span>opt_params)</span>
<span id="cb50-216"><a href="#cb50-216" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-217"><a href="#cb50-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-218"><a href="#cb50-218" aria-hidden="true" tabindex="-1"></a>We'll load the resulting TextGrid into R, zoom into the sound a bit, and compare the previous results with default parameters (in red) with the new results with optimized parameters (in blue).</span>
<span id="cb50-219"><a href="#cb50-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-222"><a href="#cb50-222" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-223"><a href="#cb50-223" aria-hidden="true" tabindex="-1"></a>vl_tg_predVOT_opt <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">tg.read</span>(<span class="st">'vl/tg/1.TextGrid'</span>)</span>
<span id="cb50-224"><a href="#cb50-224" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_snd<span class="sc">$</span>t, <span class="at">y=</span>vl_snd<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb50-225"><a href="#cb50-225" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.25</span>))</span>
<span id="cb50-226"><a href="#cb50-226" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT<span class="sc">$</span>vot<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'red'</span>)</span>
<span id="cb50-227"><a href="#cb50-227" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vl_tg_predVOT_opt<span class="sc">$</span>vot<span class="sc">$</span>t1, <span class="at">col=</span><span class="st">'blue'</span>)</span>
<span id="cb50-228"><a href="#cb50-228" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-229"><a href="#cb50-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-230"><a href="#cb50-230" aria-hidden="true" tabindex="-1"></a>There is no noticeable difference in the predicted burst location, but the predicted voicing onset location is significantly improved.</span>
<span id="cb50-231"><a href="#cb50-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-234"><a href="#cb50-234" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-235"><a href="#cb50-235" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb50-236"><a href="#cb50-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-237"><a href="#cb50-237" aria-hidden="true" tabindex="-1"></a><span class="co">#remove programmatically created folder</span></span>
<span id="cb50-238"><a href="#cb50-238" aria-hidden="true" tabindex="-1"></a><span class="fu">unlink</span>(<span class="st">'vl/tg'</span>, <span class="at">recursive=</span><span class="cn">TRUE</span>)</span>
<span id="cb50-239"><a href="#cb50-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-240"><a href="#cb50-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-241"><a href="#cb50-241" aria-hidden="true" tabindex="-1"></a><span class="fu">## How does it work?</span></span>
<span id="cb50-242"><a href="#cb50-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-243"><a href="#cb50-243" aria-hidden="true" tabindex="-1"></a>In this section, I briefly describe what is going on under the hood when VOT is predicted. This should also help understand all the obscure arguments that make up the parameters lists.</span>
<span id="cb50-244"><a href="#cb50-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-245"><a href="#cb50-245" aria-hidden="true" tabindex="-1"></a><span class="fu">### Positive VOT</span></span>
<span id="cb50-246"><a href="#cb50-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-247"><a href="#cb50-247" aria-hidden="true" tabindex="-1"></a>Positive VOT is predicted using the function <span class="in">`positiveVOT()`</span>. The process will be exemplified using this sound file:</span>
<span id="cb50-248"><a href="#cb50-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-251"><a href="#cb50-251" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-252"><a href="#cb50-252" aria-hidden="true" tabindex="-1"></a>vl_ex <span class="ot">&lt;-</span> rPraat<span class="sc">::</span><span class="fu">snd.read</span>(<span class="st">'vl_training/1.wav'</span>)</span>
<span id="cb50-253"><a href="#cb50-253" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">y=</span>vl_ex<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb50-254"><a href="#cb50-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-255"><a href="#cb50-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-256"><a href="#cb50-256" aria-hidden="true" tabindex="-1"></a>The first step to this process is to look for a stop closure. We do this by dividing up the first half of the sound file into intervals of duration <span class="in">`closure_interval`</span> (default is <span class="in">`10`</span> ms), and finding the one with the lowest mean amplitude. The intervals look like this:</span>
<span id="cb50-257"><a href="#cb50-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-260"><a href="#cb50-260" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-261"><a href="#cb50-261" aria-hidden="true" tabindex="-1"></a><span class="co">#extract the sound samples, specify column 1 to get vector instead of array (there's only 1 column so doesn't matter)</span></span>
<span id="cb50-262"><a href="#cb50-262" aria-hidden="true" tabindex="-1"></a>sound <span class="ot">&lt;-</span> vl_ex<span class="sc">$</span>sig[,<span class="dv">1</span>]</span>
<span id="cb50-263"><a href="#cb50-263" aria-hidden="true" tabindex="-1"></a><span class="co">#extract sample rate</span></span>
<span id="cb50-264"><a href="#cb50-264" aria-hidden="true" tabindex="-1"></a>sr <span class="ot">&lt;-</span> vl_ex<span class="sc">$</span>fs</span>
<span id="cb50-265"><a href="#cb50-265" aria-hidden="true" tabindex="-1"></a><span class="co">#set closure interval to default 10</span></span>
<span id="cb50-266"><a href="#cb50-266" aria-hidden="true" tabindex="-1"></a>closure_interval <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb50-267"><a href="#cb50-267" aria-hidden="true" tabindex="-1"></a><span class="co">#convert closure interval to seconds</span></span>
<span id="cb50-268"><a href="#cb50-268" aria-hidden="true" tabindex="-1"></a>ci <span class="ot">&lt;-</span> closure_interval<span class="sc">/</span><span class="dv">1000</span></span>
<span id="cb50-269"><a href="#cb50-269" aria-hidden="true" tabindex="-1"></a><span class="co">#how many 10 ms intervals in the first half of the sound file? round up</span></span>
<span id="cb50-270"><a href="#cb50-270" aria-hidden="true" tabindex="-1"></a>sqlen <span class="ot">&lt;-</span> <span class="fu">ceiling</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span> <span class="sc">/</span> sr <span class="sc">/</span> ci)</span>
<span id="cb50-271"><a href="#cb50-271" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of 10 ms intervals</span></span>
<span id="cb50-272"><a href="#cb50-272" aria-hidden="true" tabindex="-1"></a>sq_clo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>sr<span class="sc">*</span>ci, <span class="at">to=</span>sqlen<span class="sc">*</span>sr<span class="sc">*</span>ci, <span class="at">by=</span>sr<span class="sc">*</span>ci)</span>
<span id="cb50-273"><a href="#cb50-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-274"><a href="#cb50-274" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-275"><a href="#cb50-275" aria-hidden="true" tabindex="-1"></a><span class="co">#add grey vertical lines each 10 ms</span></span>
<span id="cb50-276"><a href="#cb50-276" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'grey'</span>)</span>
<span id="cb50-277"><a href="#cb50-277" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-278"><a href="#cb50-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-279"><a href="#cb50-279" aria-hidden="true" tabindex="-1"></a>The midpoint of the interval with the lowest mean amplitude is assumed to be part of the stop closure. This point is marked in red below.</span>
<span id="cb50-280"><a href="#cb50-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-283"><a href="#cb50-283" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-284"><a href="#cb50-284" aria-hidden="true" tabindex="-1"></a><span class="co">#make empty vector</span></span>
<span id="cb50-285"><a href="#cb50-285" aria-hidden="true" tabindex="-1"></a>mean_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-286"><a href="#cb50-286" aria-hidden="true" tabindex="-1"></a><span class="co">#set counter</span></span>
<span id="cb50-287"><a href="#cb50-287" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-288"><a href="#cb50-288" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through intervals</span></span>
<span id="cb50-289"><a href="#cb50-289" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_clo) {</span>
<span id="cb50-290"><a href="#cb50-290" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with mean amplitude by interval ignoring sign</span></span>
<span id="cb50-291"><a href="#cb50-291" aria-hidden="true" tabindex="-1"></a>  mean_amp[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">abs</span>(sound[(s<span class="sc">-</span>(sr<span class="sc">*</span>ci)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>s]))</span>
<span id="cb50-292"><a href="#cb50-292" aria-hidden="true" tabindex="-1"></a>  <span class="co">#increase counter</span></span>
<span id="cb50-293"><a href="#cb50-293" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-294"><a href="#cb50-294" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-295"><a href="#cb50-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-296"><a href="#cb50-296" aria-hidden="true" tabindex="-1"></a><span class="co">#closure is halfway through the interval with lowest mean amplitude</span></span>
<span id="cb50-297"><a href="#cb50-297" aria-hidden="true" tabindex="-1"></a>clo <span class="ot">&lt;-</span> (<span class="fu">which</span>(mean_amp<span class="sc">==</span><span class="fu">min</span>(mean_amp)) <span class="sc">-</span> <span class="fl">0.5</span>) <span class="sc">*</span> sr <span class="sc">*</span> ci</span>
<span id="cb50-298"><a href="#cb50-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-299"><a href="#cb50-299" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-300"><a href="#cb50-300" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'grey'</span>)</span>
<span id="cb50-301"><a href="#cb50-301" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at predicted closure</span></span>
<span id="cb50-302"><a href="#cb50-302" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-303"><a href="#cb50-303" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-304"><a href="#cb50-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-305"><a href="#cb50-305" aria-hidden="true" tabindex="-1"></a>Next up, we predict that the stop release is the first brief interval after the closure where the amplitude is above some baseline. We split up the rest of the sound file after the predicted closure into intervals of 1 ms. We predict that the release is the first interval where the maximum amplitude is above a 1 / <span class="in">`release_param`</span> (default is <span class="in">`15`</span>) proportion of the highest amplitude in the sound. The highest amplitude is marked in blue here:</span>
<span id="cb50-306"><a href="#cb50-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-309"><a href="#cb50-309" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-310"><a href="#cb50-310" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-311"><a href="#cb50-311" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at highest amplitude</span></span>
<span id="cb50-312"><a href="#cb50-312" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(sound)<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-313"><a href="#cb50-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-314"><a href="#cb50-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-315"><a href="#cb50-315" aria-hidden="true" tabindex="-1"></a>And this is the first interval where the maximum amplitude is above 1/15 of that, marked in red:</span>
<span id="cb50-316"><a href="#cb50-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-319"><a href="#cb50-319" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-320"><a href="#cb50-320" aria-hidden="true" tabindex="-1"></a><span class="co">#set release_param argument at default 15</span></span>
<span id="cb50-321"><a href="#cb50-321" aria-hidden="true" tabindex="-1"></a>release_param <span class="ot">&lt;-</span> <span class="dv">15</span></span>
<span id="cb50-322"><a href="#cb50-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-323"><a href="#cb50-323" aria-hidden="true" tabindex="-1"></a><span class="co">#named object for number of samples per 1 ms, must be a whole number</span></span>
<span id="cb50-324"><a href="#cb50-324" aria-hidden="true" tabindex="-1"></a>step <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="dv">1</span> <span class="sc">*</span> (sr<span class="sc">/</span><span class="dv">1000</span>))</span>
<span id="cb50-325"><a href="#cb50-325" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of 1ms intervals after predicted closure</span></span>
<span id="cb50-326"><a href="#cb50-326" aria-hidden="true" tabindex="-1"></a>sq_rel <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>clo, <span class="at">to=</span><span class="fu">length</span>(sound), <span class="at">by=</span>step)</span>
<span id="cb50-327"><a href="#cb50-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-328"><a href="#cb50-328" aria-hidden="true" tabindex="-1"></a><span class="co">#empty vector, reset counter</span></span>
<span id="cb50-329"><a href="#cb50-329" aria-hidden="true" tabindex="-1"></a>max_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-330"><a href="#cb50-330" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-331"><a href="#cb50-331" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through 1ms intervals</span></span>
<span id="cb50-332"><a href="#cb50-332" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> <span class="fu">abs</span>(sq_rel)) {</span>
<span id="cb50-333"><a href="#cb50-333" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with most extreme amplitude per interval, ignoring sign</span></span>
<span id="cb50-334"><a href="#cb50-334" aria-hidden="true" tabindex="-1"></a>  max_amp[i] <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>step<span class="dv">-1</span>)]))</span>
<span id="cb50-335"><a href="#cb50-335" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-336"><a href="#cb50-336" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-337"><a href="#cb50-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-338"><a href="#cb50-338" aria-hidden="true" tabindex="-1"></a><span class="co">#determine baseline amplitude for predicting stop release</span></span>
<span id="cb50-339"><a href="#cb50-339" aria-hidden="true" tabindex="-1"></a>spike_size <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(sound))<span class="sc">/</span>release_param</span>
<span id="cb50-340"><a href="#cb50-340" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of intervals above baseline</span></span>
<span id="cb50-341"><a href="#cb50-341" aria-hidden="true" tabindex="-1"></a>spike <span class="ot">&lt;-</span> <span class="fu">which</span>(max_amp <span class="sc">&gt;</span> spike_size)</span>
<span id="cb50-342"><a href="#cb50-342" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of first interval above baseline</span></span>
<span id="cb50-343"><a href="#cb50-343" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> <span class="fu">abs</span>((clo[<span class="dv">1</span>] <span class="sc">+</span> ((spike[<span class="dv">1</span>])<span class="sc">*</span>step))<span class="sc">-</span>step)</span>
<span id="cb50-344"><a href="#cb50-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-345"><a href="#cb50-345" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-346"><a href="#cb50-346" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(sound)<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-347"><a href="#cb50-347" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for predicted release</span></span>
<span id="cb50-348"><a href="#cb50-348" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>rel<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-349"><a href="#cb50-349" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-350"><a href="#cb50-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-351"><a href="#cb50-351" aria-hidden="true" tabindex="-1"></a>Next up, by default we predict that the voicing onset is the first short interval where the mean autocorrelation of samples is above some baseline. We split the rest of the sound file after the predicted release into intervals with a duration of <span class="in">`vo_granularity`</span> ms (default is <span class="in">`1`</span>), and assume that the first voiced interval is the one where samples are on average autocorrelated more than <span class="in">`vo_param`</span> % (default is <span class="in">`0.85`</span>, i.e. 85%) of the most autocorrelated interval in the sound file. The general idea is that voiced intervals are periodic, so correlation between adjacent samples should generally be quite high. On the other hand, intervals that occur during a voiceless stop release are noisy, so correlation between adjacent samples should be very low.</span>
<span id="cb50-352"><a href="#cb50-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-353"><a href="#cb50-353" aria-hidden="true" tabindex="-1"></a>This may need a bit of unpacking. The most autocorrelated 1 ms interval is indicated with a blue line here:</span>
<span id="cb50-354"><a href="#cb50-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-357"><a href="#cb50-357" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-358"><a href="#cb50-358" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_granularity as default 1</span></span>
<span id="cb50-359"><a href="#cb50-359" aria-hidden="true" tabindex="-1"></a>vo_granularity <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-360"><a href="#cb50-360" aria-hidden="true" tabindex="-1"></a><span class="co">#convert vo_granularity to number of samples</span></span>
<span id="cb50-361"><a href="#cb50-361" aria-hidden="true" tabindex="-1"></a>vo_int <span class="ot">&lt;-</span> vo_granularity<span class="sc">*</span>step</span>
<span id="cb50-362"><a href="#cb50-362" aria-hidden="true" tabindex="-1"></a><span class="co">#make vector of intervals</span></span>
<span id="cb50-363"><a href="#cb50-363" aria-hidden="true" tabindex="-1"></a>sq_vo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>rel<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">5</span>), <span class="at">to=</span>rel<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">200</span>), <span class="at">by=</span>vo_int)</span>
<span id="cb50-364"><a href="#cb50-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-365"><a href="#cb50-365" aria-hidden="true" tabindex="-1"></a>mu_acf <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-366"><a href="#cb50-366" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-367"><a href="#cb50-367" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_vo) {</span>
<span id="cb50-368"><a href="#cb50-368" aria-hidden="true" tabindex="-1"></a>  <span class="co">#run acf on samples in interval, don't plot, ignore NAs</span></span>
<span id="cb50-369"><a href="#cb50-369" aria-hidden="true" tabindex="-1"></a>  acf <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">acf</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>step<span class="dv">-1</span>)], <span class="at">plot=</span>F,</span>
<span id="cb50-370"><a href="#cb50-370" aria-hidden="true" tabindex="-1"></a>                    <span class="at">na.action=</span>stats<span class="sc">::</span>na.pass)</span>
<span id="cb50-371"><a href="#cb50-371" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with mean autocorrelation across all lags</span></span>
<span id="cb50-372"><a href="#cb50-372" aria-hidden="true" tabindex="-1"></a>  mu_acf[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(acf<span class="sc">$</span>acf)</span>
<span id="cb50-373"><a href="#cb50-373" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-374"><a href="#cb50-374" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-375"><a href="#cb50-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-376"><a href="#cb50-376" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-377"><a href="#cb50-377" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for most autocorrelated interval</span></span>
<span id="cb50-378"><a href="#cb50-378" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_vo[<span class="fu">which.max</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-379"><a href="#cb50-379" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-380"><a href="#cb50-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-381"><a href="#cb50-381" aria-hidden="true" tabindex="-1"></a>If we zoom into just that one ms interval, it looks like this:</span>
<span id="cb50-382"><a href="#cb50-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-385"><a href="#cb50-385" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-386"><a href="#cb50-386" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of samples in most autocorrelated interval</span></span>
<span id="cb50-387"><a href="#cb50-387" aria-hidden="true" tabindex="-1"></a>max_acf <span class="ot">&lt;-</span> ((<span class="fu">which.max</span>(mu_acf))<span class="sc">*</span>step)<span class="sc">+</span>rel</span>
<span id="cb50-388"><a href="#cb50-388" aria-hidden="true" tabindex="-1"></a><span class="co">#plot just those samples from the sound object</span></span>
<span id="cb50-389"><a href="#cb50-389" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sound[max_acf<span class="sc">:</span>(max_acf<span class="sc">+</span>vo_int)], <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb50-390"><a href="#cb50-390" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Time (individual samples)'</span>)</span>
<span id="cb50-391"><a href="#cb50-391" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-392"><a href="#cb50-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-393"><a href="#cb50-393" aria-hidden="true" tabindex="-1"></a>This clearly looks periodic. If we use the function <span class="in">`acf()`</span> as below, we can see that adjacent samples are highly correlated, and autocorrelation with samples at lags up to six samples removed is generally quite high.</span>
<span id="cb50-394"><a href="#cb50-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-397"><a href="#cb50-397" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-398"><a href="#cb50-398" aria-hidden="true" tabindex="-1"></a><span class="co">#rerun acf on that interval, plot results this time</span></span>
<span id="cb50-399"><a href="#cb50-399" aria-hidden="true" tabindex="-1"></a><span class="fu">acf</span>(sound[max_acf<span class="sc">:</span>(max_acf<span class="sc">+</span>vo_int)], <span class="at">main=</span><span class="st">''</span>)</span>
<span id="cb50-400"><a href="#cb50-400" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-401"><a href="#cb50-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-402"><a href="#cb50-402" aria-hidden="true" tabindex="-1"></a>This, on the other hand, is our least autocorrelated interval:</span>
<span id="cb50-403"><a href="#cb50-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-406"><a href="#cb50-406" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-407"><a href="#cb50-407" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-408"><a href="#cb50-408" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for least autocorrelated interval</span></span>
<span id="cb50-409"><a href="#cb50-409" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>rel<span class="sc">/</span>sr<span class="sc">+</span>sq_vo[<span class="fu">which.min</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-410"><a href="#cb50-410" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-411"><a href="#cb50-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-412"><a href="#cb50-412" aria-hidden="true" tabindex="-1"></a>If we zoom in to just that one interval, we see a very jagged line.</span>
<span id="cb50-413"><a href="#cb50-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-416"><a href="#cb50-416" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-417"><a href="#cb50-417" aria-hidden="true" tabindex="-1"></a>min_acf <span class="ot">&lt;-</span> ((<span class="fu">which.min</span>(mu_acf))<span class="sc">*</span>step)<span class="sc">+</span>rel</span>
<span id="cb50-418"><a href="#cb50-418" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sound[min_acf<span class="sc">:</span>(min_acf<span class="sc">+</span>vo_int)], <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, </span>
<span id="cb50-419"><a href="#cb50-419" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Time (individual samples)'</span>)</span>
<span id="cb50-420"><a href="#cb50-420" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-421"><a href="#cb50-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-422"><a href="#cb50-422" aria-hidden="true" tabindex="-1"></a>And running <span class="in">`acf()`</span> again, we see that autocorrelation is very low.</span>
<span id="cb50-423"><a href="#cb50-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-426"><a href="#cb50-426" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-427"><a href="#cb50-427" aria-hidden="true" tabindex="-1"></a><span class="fu">acf</span>(sound[min_acf<span class="sc">:</span>(min_acf<span class="sc">+</span>vo_int)], <span class="at">main=</span><span class="st">''</span>)</span>
<span id="cb50-428"><a href="#cb50-428" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-429"><a href="#cb50-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-430"><a href="#cb50-430" aria-hidden="true" tabindex="-1"></a>The first interval where the mean autocorrelation is above 85% of the most autocorrelated interval (i.e., the predicted voicing onset) is indicated with a red line here:</span>
<span id="cb50-431"><a href="#cb50-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-434"><a href="#cb50-434" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-435"><a href="#cb50-435" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_param as default 0.85</span></span>
<span id="cb50-436"><a href="#cb50-436" aria-hidden="true" tabindex="-1"></a>vo_param <span class="ot">&lt;-</span> <span class="fl">0.85</span></span>
<span id="cb50-437"><a href="#cb50-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-438"><a href="#cb50-438" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of intervals where autocorrelation is above voicing onset baseline</span></span>
<span id="cb50-439"><a href="#cb50-439" aria-hidden="true" tabindex="-1"></a>hi_acf <span class="ot">&lt;-</span> <span class="fu">which</span>(mu_acf <span class="sc">&gt;</span> <span class="fu">max</span>(mu_acf, <span class="at">na.rm=</span>T)<span class="sc">*</span>vo_param)</span>
<span id="cb50-440"><a href="#cb50-440" aria-hidden="true" tabindex="-1"></a><span class="co">#voicing onset is predicted to be 1ms after the start of the second interval </span></span>
<span id="cb50-441"><a href="#cb50-441" aria-hidden="true" tabindex="-1"></a><span class="co">#above the baseline. helps to reduce the influence of random fluctuations, and</span></span>
<span id="cb50-442"><a href="#cb50-442" aria-hidden="true" tabindex="-1"></a><span class="co">#usually the start of the first interval above the baseline precedes visible voicing.</span></span>
<span id="cb50-443"><a href="#cb50-443" aria-hidden="true" tabindex="-1"></a>vo <span class="ot">&lt;-</span> (rel <span class="sc">+</span> (hi_acf[<span class="dv">2</span>]<span class="sc">*</span>(step<span class="sc">*</span>vo_granularity)) <span class="sc">+</span> step)</span>
<span id="cb50-444"><a href="#cb50-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-445"><a href="#cb50-445" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vl_ex<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-446"><a href="#cb50-446" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sq_vo[<span class="fu">which.max</span>(mu_acf)]<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-447"><a href="#cb50-447" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>vo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-448"><a href="#cb50-448" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-449"><a href="#cb50-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-450"><a href="#cb50-450" aria-hidden="true" tabindex="-1"></a>Using the default parameters, this is exactly what goes on under the hood when the function <span class="in">`positiveVOT()`</span> is called! One of the default parameters is <span class="in">`vo_method='acf'`</span>, which implements the autocorrelation-based method for predicting voicing onset that we just saw. This is generally the most precise and by far the fastest method, but it is also a little fickle and will fail for lower quality audio or adverse recording conditions.</span>
<span id="cb50-451"><a href="#cb50-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-452"><a href="#cb50-452" aria-hidden="true" tabindex="-1"></a>For this reason, another possibility is using the alternative <span class="in">`vo_method='f0'`</span>. This method simply runs the pitch tracking algorithm implemented in the <span class="in">`pitchtrack()`</span> function in the <span class="in">`phonTools`</span> package, and predicts that voicing onset begins at the time of the first successful pitch measure after the stop release. The arguments <span class="in">`f0_wl`</span> and <span class="in">`f0_minacf`</span> are passed along to <span class="in">`phonTools::pitchtrack()`</span> (as that function's arguments <span class="in">`minacf`</span> and <span class="in">`windowlength`</span>). Note that the default <span class="in">`f0_wl`</span> is 30 ms, which is quite a bit lower than the <span class="in">`phonTools::pitchtrack()`</span> default of <span class="in">`50`</span>; this seems to give better results when the purpose isn't actually to measure pitch, but to find the first instance of voicing.</span>
<span id="cb50-453"><a href="#cb50-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-454"><a href="#cb50-454" aria-hidden="true" tabindex="-1"></a>Finally, <span class="in">`positiveVOT()`</span> also takes the argument <span class="in">`f0_first`</span>, where the default is <span class="in">`FALSE`</span>. If set to <span class="in">`TRUE`</span>, the prediction process starts by finding the longest stretch of continuous pitch using <span class="in">`phonTools::pitchtrack()`</span>, and subsequently looking for a stop release only within the 200 ms preceding the beginning of that stretch. As with <span class="in">`vo_method='f0'`</span>, this is a relatively slow method, but can give better results when the recordings conditions and/or audio quality is suboptimal.</span>
<span id="cb50-455"><a href="#cb50-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-456"><a href="#cb50-456" aria-hidden="true" tabindex="-1"></a><span class="fu">### Negative VOT</span></span>
<span id="cb50-457"><a href="#cb50-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-458"><a href="#cb50-458" aria-hidden="true" tabindex="-1"></a>Negative VOT is predicted using the function <span class="in">`negativeVOT()`</span>. The process will be exemplified using the same voiced stop as we saw above. Just as when predicting positive VOT, the first step is to locate a stop closure by searching for the most silent interval of duration <span class="in">`closure_interval`</span> (default is <span class="in">`10`</span>) in the first half of the sound file. The implementation and result of this are shown here:</span>
<span id="cb50-459"><a href="#cb50-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-462"><a href="#cb50-462" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-463"><a href="#cb50-463" aria-hidden="true" tabindex="-1"></a><span class="co">#extract sound samples and overwrite sound object</span></span>
<span id="cb50-464"><a href="#cb50-464" aria-hidden="true" tabindex="-1"></a><span class="co">#see same procedure for positiveVOT() above for commented code</span></span>
<span id="cb50-465"><a href="#cb50-465" aria-hidden="true" tabindex="-1"></a>sound <span class="ot">&lt;-</span> vd_snd<span class="sc">$</span>sig[,<span class="dv">1</span>]</span>
<span id="cb50-466"><a href="#cb50-466" aria-hidden="true" tabindex="-1"></a>closure_interval <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb50-467"><a href="#cb50-467" aria-hidden="true" tabindex="-1"></a>ci <span class="ot">&lt;-</span> closure_interval<span class="sc">/</span><span class="dv">1000</span></span>
<span id="cb50-468"><a href="#cb50-468" aria-hidden="true" tabindex="-1"></a>sqlen <span class="ot">&lt;-</span> <span class="fu">ceiling</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span> <span class="sc">/</span> sr <span class="sc">/</span> ci)</span>
<span id="cb50-469"><a href="#cb50-469" aria-hidden="true" tabindex="-1"></a>sq_clo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>sr<span class="sc">*</span>ci, <span class="at">to=</span>sqlen<span class="sc">*</span>sr<span class="sc">*</span>ci, <span class="at">by=</span>sr<span class="sc">*</span>ci)</span>
<span id="cb50-470"><a href="#cb50-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-471"><a href="#cb50-471" aria-hidden="true" tabindex="-1"></a>mean_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-472"><a href="#cb50-472" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-473"><a href="#cb50-473" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_clo) {</span>
<span id="cb50-474"><a href="#cb50-474" aria-hidden="true" tabindex="-1"></a>  mean_amp[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">abs</span>(sound[(s<span class="sc">-</span>(sr<span class="sc">*</span>ci)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>s]))</span>
<span id="cb50-475"><a href="#cb50-475" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-476"><a href="#cb50-476" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-477"><a href="#cb50-477" aria-hidden="true" tabindex="-1"></a>clo <span class="ot">&lt;-</span> (<span class="fu">which</span>(mean_amp<span class="sc">==</span><span class="fu">min</span>(mean_amp)) <span class="sc">-</span> <span class="fl">0.5</span>) <span class="sc">*</span> sr <span class="sc">*</span> ci</span>
<span id="cb50-478"><a href="#cb50-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-479"><a href="#cb50-479" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-480"><a href="#cb50-480" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>clo<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-481"><a href="#cb50-481" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-482"><a href="#cb50-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-483"><a href="#cb50-483" aria-hidden="true" tabindex="-1"></a>The default method for finding voicing onset is very similar for voiced and voiceless stops: the rest of the sound file after the predicted time of closure is divided into short intervals of duration <span class="in">`vo_granularity`</span> (default is here <span class="in">`1.2`</span> ms), and voicing onset is predicted to be the first interval where autocorrelation of samples within the interval is above some baseline -- default is 90% of the most highly autocorrelated interval in the sound file (<span class="in">`vo_param = 0.9`</span>). The implementation and result of this are shown here:</span>
<span id="cb50-484"><a href="#cb50-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-487"><a href="#cb50-487" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-488"><a href="#cb50-488" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_granularity as default 1.2</span></span>
<span id="cb50-489"><a href="#cb50-489" aria-hidden="true" tabindex="-1"></a>vo_granularity <span class="ot">&lt;-</span> <span class="fl">1.2</span></span>
<span id="cb50-490"><a href="#cb50-490" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of intervals</span></span>
<span id="cb50-491"><a href="#cb50-491" aria-hidden="true" tabindex="-1"></a>sq_vo <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>clo, <span class="at">to=</span><span class="fu">length</span>(sound), <span class="at">by=</span>(step<span class="sc">*</span>vo_granularity))</span>
<span id="cb50-492"><a href="#cb50-492" aria-hidden="true" tabindex="-1"></a><span class="co">#set vo_param as default 0.9</span></span>
<span id="cb50-493"><a href="#cb50-493" aria-hidden="true" tabindex="-1"></a>vo_param <span class="ot">&lt;-</span> <span class="fl">0.9</span></span>
<span id="cb50-494"><a href="#cb50-494" aria-hidden="true" tabindex="-1"></a>mu_acf <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-495"><a href="#cb50-495" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-496"><a href="#cb50-496" aria-hidden="true" tabindex="-1"></a><span class="co">#see same procedure for positiveVOT() above</span></span>
<span id="cb50-497"><a href="#cb50-497" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_vo) {</span>
<span id="cb50-498"><a href="#cb50-498" aria-hidden="true" tabindex="-1"></a>  acf <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">acf</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>(step<span class="sc">*</span>vo_granularity)<span class="sc">-</span><span class="dv">1</span>)], <span class="at">plot=</span>F,</span>
<span id="cb50-499"><a href="#cb50-499" aria-hidden="true" tabindex="-1"></a>                    <span class="at">na.action=</span>stats<span class="sc">::</span>na.pass)</span>
<span id="cb50-500"><a href="#cb50-500" aria-hidden="true" tabindex="-1"></a>  mu_acf[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(acf<span class="sc">$</span>acf)</span>
<span id="cb50-501"><a href="#cb50-501" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-502"><a href="#cb50-502" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-503"><a href="#cb50-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-504"><a href="#cb50-504" aria-hidden="true" tabindex="-1"></a>hi_acf <span class="ot">&lt;-</span> <span class="fu">which</span>(mu_acf <span class="sc">&gt;</span> <span class="fu">max</span>(mu_acf, <span class="at">na.rm=</span>T)<span class="sc">*</span>vo_param)</span>
<span id="cb50-505"><a href="#cb50-505" aria-hidden="true" tabindex="-1"></a>f0_start <span class="ot">&lt;-</span> (clo <span class="sc">+</span> (hi_acf[<span class="dv">2</span>]<span class="sc">*</span>(step<span class="sc">*</span>vo_granularity)) <span class="sc">+</span> step)</span>
<span id="cb50-506"><a href="#cb50-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-507"><a href="#cb50-507" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-508"><a href="#cb50-508" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>f0_start<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-509"><a href="#cb50-509" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-510"><a href="#cb50-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-511"><a href="#cb50-511" aria-hidden="true" tabindex="-1"></a>As with <span class="in">`positiveVOT()`</span>, <span class="in">`negativeVOT()`</span> offers the alternative method for locating voicing onset <span class="in">`vo_method='f0'`</span> with the default settings <span class="in">`f0_wl=50`</span> and <span class="in">`f0_minacf=0.5`</span> passed onto the <span class="in">`pitchtrack()`</span> function of the <span class="in">`phonTools`</span> package.</span>
<span id="cb50-512"><a href="#cb50-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-513"><a href="#cb50-513" aria-hidden="true" tabindex="-1"></a>Finding the release of a prevoiced stop is trickier. The default method of <span class="in">`negativeVOT()`</span> is to search for the so-called *transient phase* (`rel_method='transient'`). The transient phase of a stop is when the compressed air in the oral tract is discharged immediately at the time of the stop release. This results in a fairly even distribution of energy throughout the spectrum with a linear drop-off in energy at higher frequencies -- in other words, a particularly *smooth* spectrum. These are tricky to find automatically as they're very short.</span>
<span id="cb50-514"><a href="#cb50-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-515"><a href="#cb50-515" aria-hidden="true" tabindex="-1"></a>The way this is implemented in <span class="in">`negativeVOT()`</span> is by using the <span class="in">`spectralslice()`</span> function in <span class="in">`phonTools`</span> to generate FFT spectral slices of 1 ms sound intervals at each 10 samples after the predicted voicing onset. An FFT spectrum in R is just a vector of power measures by frequency bins; I estimate spectral smoothness by taking the standard deviation of the difference in power among adjacent frequency bins in the spectrum. A low number should indicate a smooth spectrum. I'll unpack this with some code and plots.</span>
<span id="cb50-516"><a href="#cb50-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-517"><a href="#cb50-517" aria-hidden="true" tabindex="-1"></a>This bit of code generates the spectra and calculates smoothness:</span>
<span id="cb50-518"><a href="#cb50-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-521"><a href="#cb50-521" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-522"><a href="#cb50-522" aria-hidden="true" tabindex="-1"></a><span class="co">#to save time, search only half the duration of the sound file after predicted voicing onset</span></span>
<span id="cb50-523"><a href="#cb50-523" aria-hidden="true" tabindex="-1"></a>srch <span class="ot">&lt;-</span> sound[f0_start<span class="sc">:</span>(<span class="fu">length</span>(sound)<span class="sc">/</span><span class="dv">2</span>)]</span>
<span id="cb50-524"><a href="#cb50-524" aria-hidden="true" tabindex="-1"></a><span class="co">#set starting times each 10 samples for intervals to generate spectral slices from</span></span>
<span id="cb50-525"><a href="#cb50-525" aria-hidden="true" tabindex="-1"></a>steps <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">:</span>(<span class="fu">round</span>(<span class="fu">length</span>(srch)<span class="sc">/</span>step)<span class="sc">*</span><span class="dv">10</span>)</span>
<span id="cb50-526"><a href="#cb50-526" aria-hidden="true" tabindex="-1"></a>smoothness <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-527"><a href="#cb50-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-528"><a href="#cb50-528" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through starting times</span></span>
<span id="cb50-529"><a href="#cb50-529" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> steps) {</span>
<span id="cb50-530"><a href="#cb50-530" aria-hidden="true" tabindex="-1"></a>  <span class="co">#determine 1 ms interval times</span></span>
<span id="cb50-531"><a href="#cb50-531" aria-hidden="true" tabindex="-1"></a>  stp <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((i<span class="sc">*</span>step) <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb50-532"><a href="#cb50-532" aria-hidden="true" tabindex="-1"></a>  <span class="co">#generate FFT spectral slice, don't plot</span></span>
<span id="cb50-533"><a href="#cb50-533" aria-hidden="true" tabindex="-1"></a>  <span class="co">#spectralslice() returns a matrix, the second column contains power estimates, save those</span></span>
<span id="cb50-534"><a href="#cb50-534" aria-hidden="true" tabindex="-1"></a>  slice <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(stp<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>stp], <span class="at">show=</span>F)[,<span class="dv">2</span>]</span>
<span id="cb50-535"><a href="#cb50-535" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with spectral smoothness estimates</span></span>
<span id="cb50-536"><a href="#cb50-536" aria-hidden="true" tabindex="-1"></a>  smoothness[i<span class="dv">-9</span>] <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">sd</span>(<span class="fu">diff</span>(slice))</span>
<span id="cb50-537"><a href="#cb50-537" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-538"><a href="#cb50-538" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-539"><a href="#cb50-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-540"><a href="#cb50-540" aria-hidden="true" tabindex="-1"></a>This is an example of a rather jagged spectrum with a fairly high power difference between adjacent frequency bins. There's voicing here, and especially the difference between the first few frequency bins is huge.</span>
<span id="cb50-541"><a href="#cb50-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-544"><a href="#cb50-544" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-545"><a href="#cb50-545" aria-hidden="true" tabindex="-1"></a><span class="co">#find most jagged spectrum (high "smoothness" estimate = low smoothness)</span></span>
<span id="cb50-546"><a href="#cb50-546" aria-hidden="true" tabindex="-1"></a>max_smooth <span class="ot">&lt;-</span> <span class="fu">which</span>(smoothness <span class="sc">==</span> <span class="fu">max</span>(smoothness))</span>
<span id="cb50-547"><a href="#cb50-547" aria-hidden="true" tabindex="-1"></a><span class="co">#determine location of most jagged spectrum</span></span>
<span id="cb50-548"><a href="#cb50-548" aria-hidden="true" tabindex="-1"></a>jagged <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((steps[max_smooth]<span class="sc">*</span>step)<span class="sc">/</span><span class="dv">10</span>)</span>
<span id="cb50-549"><a href="#cb50-549" aria-hidden="true" tabindex="-1"></a><span class="co">#generate that jagged spectrum again for visualization purposes, don't use </span></span>
<span id="cb50-550"><a href="#cb50-550" aria-hidden="true" tabindex="-1"></a><span class="co">#default plotting function because it doesn't return frequency in Hz scale</span></span>
<span id="cb50-551"><a href="#cb50-551" aria-hidden="true" tabindex="-1"></a>jagged_spec <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(jagged<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>jagged], <span class="at">show=</span>F)</span>
<span id="cb50-552"><a href="#cb50-552" aria-hidden="true" tabindex="-1"></a><span class="co">#plot spectrum. first matrix column has frequency values, second has power estimates</span></span>
<span id="cb50-553"><a href="#cb50-553" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>jagged_spec[,<span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">y=</span>jagged_spec[,<span class="dv">2</span>], <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb50-554"><a href="#cb50-554" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Power (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb50-555"><a href="#cb50-555" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-556"><a href="#cb50-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-557"><a href="#cb50-557" aria-hidden="true" tabindex="-1"></a>We can demonstrate this by plotting just the difference in power among adjacent frequency bins, instead of plotting the actual spectrum:</span>
<span id="cb50-558"><a href="#cb50-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-561"><a href="#cb50-561" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-562"><a href="#cb50-562" aria-hidden="true" tabindex="-1"></a><span class="co">#plot power difference between adjacent frequency bins. must exclude first bin on x axis,</span></span>
<span id="cb50-563"><a href="#cb50-563" aria-hidden="true" tabindex="-1"></a><span class="co">#because diff(x) returns a vector of size x-1</span></span>
<span id="cb50-564"><a href="#cb50-564" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span><span class="fu">diff</span>(jagged_spec[,<span class="dv">2</span>]), <span class="at">x=</span>jagged_spec[,<span class="dv">1</span>][<span class="sc">-</span><span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb50-565"><a href="#cb50-565" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Diff. betwen adjacent measures (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb50-566"><a href="#cb50-566" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-567"><a href="#cb50-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-568"><a href="#cb50-568" aria-hidden="true" tabindex="-1"></a>By comparison, this is the smoothest spectrum in the file:</span>
<span id="cb50-569"><a href="#cb50-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-572"><a href="#cb50-572" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-573"><a href="#cb50-573" aria-hidden="true" tabindex="-1"></a>min_smooth <span class="ot">&lt;-</span> <span class="fu">which</span>(smoothness <span class="sc">==</span> <span class="fu">min</span>(smoothness))</span>
<span id="cb50-574"><a href="#cb50-574" aria-hidden="true" tabindex="-1"></a>smooth <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> ((steps[min_smooth]<span class="sc">*</span>step)<span class="sc">/</span><span class="dv">10</span>)</span>
<span id="cb50-575"><a href="#cb50-575" aria-hidden="true" tabindex="-1"></a>smooth_spec <span class="ot">&lt;-</span> phonTools<span class="sc">::</span><span class="fu">spectralslice</span>(sound[(smooth<span class="sc">-</span>step<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>smooth], <span class="at">show=</span>F)</span>
<span id="cb50-576"><a href="#cb50-576" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>smooth_spec[,<span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">y=</span>smooth_spec[,<span class="dv">2</span>], <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb50-577"><a href="#cb50-577" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Power (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb50-578"><a href="#cb50-578" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-579"><a href="#cb50-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-580"><a href="#cb50-580" aria-hidden="true" tabindex="-1"></a>This is immediately clear when plotting the difference between adjacent frequency bins using the same range for the Y-axis as we did for the less smooth spectrum above.</span>
<span id="cb50-581"><a href="#cb50-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-584"><a href="#cb50-584" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-585"><a href="#cb50-585" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span><span class="fu">diff</span>(smooth_spec[,<span class="dv">2</span>]), <span class="at">x=</span>smooth_spec[,<span class="dv">1</span>][<span class="sc">-</span><span class="dv">1</span>]<span class="sc">*</span><span class="dv">10000</span>, <span class="at">type=</span><span class="st">'l'</span>, </span>
<span id="cb50-586"><a href="#cb50-586" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Diff. betwen adjacent measures (dB)'</span>, <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>,</span>
<span id="cb50-587"><a href="#cb50-587" aria-hidden="true" tabindex="-1"></a>     <span class="co">#set limits on y axis identically to the previous difference plot</span></span>
<span id="cb50-588"><a href="#cb50-588" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">range</span>(<span class="fu">diff</span>(jagged_spec)))</span>
<span id="cb50-589"><a href="#cb50-589" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-590"><a href="#cb50-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-591"><a href="#cb50-591" aria-hidden="true" tabindex="-1"></a>And this is the location in the sound file of that very smooth spectrum shown in red:</span>
<span id="cb50-592"><a href="#cb50-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-595"><a href="#cb50-595" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-596"><a href="#cb50-596" aria-hidden="true" tabindex="-1"></a><span class="co">#extract location of predicted release in sound file, actually just slightly after smoothest spectrum</span></span>
<span id="cb50-597"><a href="#cb50-597" aria-hidden="true" tabindex="-1"></a>pred_rel <span class="ot">&lt;-</span> f0_start <span class="sc">+</span> (((min_smooth<span class="sc">+</span><span class="dv">9</span>)<span class="sc">*</span>step) <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb50-598"><a href="#cb50-598" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-599"><a href="#cb50-599" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line at location of predicted release</span></span>
<span id="cb50-600"><a href="#cb50-600" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>pred_rel<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-601"><a href="#cb50-601" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-602"><a href="#cb50-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-603"><a href="#cb50-603" aria-hidden="true" tabindex="-1"></a>As with using autocorrelation for locating voicing onset, using the transient phase to locate the release of a voiced stop is *fickle*; if the audio quality is good, I have found that it tends to give remarkably precise results. On the other hand, when it fails, it fails completely. It is also relatively slow, as it involves generating a lot of spectral slices. An alternative method is simply looking for increases in amplitude, as the amplitude of prevoicing is usually low. This method essentially looks for the beginning of the vowel rather than the stop release itself, and as such results are somewhat less precise. This method can be set with the parameter <span class="in">`rel_method='amplitude'`</span>.</span>
<span id="cb50-604"><a href="#cb50-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-605"><a href="#cb50-605" aria-hidden="true" tabindex="-1"></a>Here, we note the maximum amplitude in 1 ms intervals after the predicted voicing onset. This results in a time series that looks like this:</span>
<span id="cb50-606"><a href="#cb50-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-609"><a href="#cb50-609" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-610"><a href="#cb50-610" aria-hidden="true" tabindex="-1"></a><span class="co">#create a vector of 500x 1ms intervals starting at predicted voicing onset</span></span>
<span id="cb50-611"><a href="#cb50-611" aria-hidden="true" tabindex="-1"></a>sq_rel <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span>f0_start, <span class="at">to=</span>f0_start<span class="sc">+</span>(step<span class="sc">*</span><span class="dv">500</span>), <span class="at">by=</span>step)</span>
<span id="cb50-612"><a href="#cb50-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-613"><a href="#cb50-613" aria-hidden="true" tabindex="-1"></a>max_amp <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb50-614"><a href="#cb50-614" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb50-615"><a href="#cb50-615" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> sq_rel) {</span>
<span id="cb50-616"><a href="#cb50-616" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill vector with highest amplitude of each interval</span></span>
<span id="cb50-617"><a href="#cb50-617" aria-hidden="true" tabindex="-1"></a>  max_amp[i] <span class="ot">&lt;-</span> <span class="fu">max</span>(sound[s<span class="sc">:</span>(s<span class="sc">+</span>(step)<span class="sc">-</span><span class="dv">1</span>)])</span>
<span id="cb50-618"><a href="#cb50-618" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> i<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb50-619"><a href="#cb50-619" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-620"><a href="#cb50-620" aria-hidden="true" tabindex="-1"></a><span class="co">#remove any NAs from max_amp vector if 500x 1ms intervals are not available </span></span>
<span id="cb50-621"><a href="#cb50-621" aria-hidden="true" tabindex="-1"></a><span class="co">#(not really necessary here)</span></span>
<span id="cb50-622"><a href="#cb50-622" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">length</span>(<span class="fu">which</span>(<span class="fu">is.na</span>(max_amp))) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb50-623"><a href="#cb50-623" aria-hidden="true" tabindex="-1"></a>  max_amp <span class="ot">&lt;-</span> max_amp[<span class="sc">-</span><span class="fu">which</span>(<span class="fu">is.na</span>(max_amp))]</span>
<span id="cb50-624"><a href="#cb50-624" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-625"><a href="#cb50-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-626"><a href="#cb50-626" aria-hidden="true" tabindex="-1"></a><span class="co">#plot maximum amplitude per interval as time series</span></span>
<span id="cb50-627"><a href="#cb50-627" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(max_amp, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span>
<span id="cb50-628"><a href="#cb50-628" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-629"><a href="#cb50-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-630"><a href="#cb50-630" aria-hidden="true" tabindex="-1"></a>This is much too jagged to be of any use, but we can get a clearer picture by smoothing it out. We do this using a discrete cosine transformation, as implemented in the <span class="in">`dct()`</span> function of <span class="in">`emuR`</span>.</span>
<span id="cb50-631"><a href="#cb50-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-634"><a href="#cb50-634" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-635"><a href="#cb50-635" aria-hidden="true" tabindex="-1"></a><span class="co">#smooth above time series using DCT based on 25 coefficients, don't plot, store fitted object</span></span>
<span id="cb50-636"><a href="#cb50-636" aria-hidden="true" tabindex="-1"></a>dct_fit <span class="ot">&lt;-</span> emuR<span class="sc">::</span><span class="fu">dct</span>(max_amp, <span class="at">m=</span><span class="dv">25</span>, <span class="at">fit=</span>T)</span>
<span id="cb50-637"><a href="#cb50-637" aria-hidden="true" tabindex="-1"></a><span class="co">#plot smoothed time series</span></span>
<span id="cb50-638"><a href="#cb50-638" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dct_fit, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window (smoothed)'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span>
<span id="cb50-639"><a href="#cb50-639" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-640"><a href="#cb50-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-641"><a href="#cb50-641" aria-hidden="true" tabindex="-1"></a>The predicted stop release is 5 ms before we see the highest velocity in this time series. The highest velocity is indicated with a blue line here:</span>
<span id="cb50-642"><a href="#cb50-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-645"><a href="#cb50-645" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-646"><a href="#cb50-646" aria-hidden="true" tabindex="-1"></a><span class="co">#save vector with difference between each adjacent max amplitude from smoothed time series</span></span>
<span id="cb50-647"><a href="#cb50-647" aria-hidden="true" tabindex="-1"></a>diff_amp <span class="ot">&lt;-</span> <span class="fu">diff</span>(dct_fit)</span>
<span id="cb50-648"><a href="#cb50-648" aria-hidden="true" tabindex="-1"></a><span class="co">#replot smoothed time series</span></span>
<span id="cb50-649"><a href="#cb50-649" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dct_fit, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Max. amplitude in window (smoothed)'</span>, <span class="at">xlab=</span><span class="st">'Window'</span>)</span>
<span id="cb50-650"><a href="#cb50-650" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line with location of highest difference</span></span>
<span id="cb50-651"><a href="#cb50-651" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.max</span>(diff_amp), <span class="at">col=</span><span class="st">'blue'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-652"><a href="#cb50-652" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-653"><a href="#cb50-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-654"><a href="#cb50-654" aria-hidden="true" tabindex="-1"></a>This predicts this stop release location:</span>
<span id="cb50-655"><a href="#cb50-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-658"><a href="#cb50-658" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb50-659"><a href="#cb50-659" aria-hidden="true" tabindex="-1"></a><span class="co">#locate predicted stop release, 5ms prior to highest amplitude increase</span></span>
<span id="cb50-660"><a href="#cb50-660" aria-hidden="true" tabindex="-1"></a>pred_rel_amp <span class="ot">&lt;-</span> sq_rel[<span class="fu">which.max</span>(diff_amp)] <span class="sc">-</span> (step <span class="sc">*</span> <span class="dv">5</span>)</span>
<span id="cb50-661"><a href="#cb50-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-662"><a href="#cb50-662" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">y=</span>sound, <span class="at">x=</span>vd_snd<span class="sc">$</span>t, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>, <span class="at">xlab=</span><span class="st">'Time (s)'</span>)</span>
<span id="cb50-663"><a href="#cb50-663" aria-hidden="true" tabindex="-1"></a><span class="co">#add vertical line for predicted stop release</span></span>
<span id="cb50-664"><a href="#cb50-664" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>pred_rel_amp<span class="sc">/</span>sr, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span>
<span id="cb50-665"><a href="#cb50-665" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb50-666"><a href="#cb50-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-667"><a href="#cb50-667" aria-hidden="true" tabindex="-1"></a>That covers all the parameters of <span class="in">`negativeVOT()`</span>.</span>
<span id="cb50-668"><a href="#cb50-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-669"><a href="#cb50-669" aria-hidden="true" tabindex="-1"></a><span class="fu">## Source of data</span></span>
<span id="cb50-670"><a href="#cb50-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-671"><a href="#cb50-671" aria-hidden="true" tabindex="-1"></a>The sound files used for demonstrating the <span class="in">`getVOT`</span> functions throughout the tutorial are in Kmhmu', taken from <span class="co">[</span><span class="ot">this OSF repository</span><span class="co">](https://osf.io/wv6qz)</span>. The data were collected to study transphonologization of onset voicing. See @kirby2022.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center"><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



<script src="../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>